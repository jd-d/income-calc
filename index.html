<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, viewport-fit=cover"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#0a0c12" />
  <link rel="icon" href="assets/favicon.png" type="image/png" />
  <link rel="apple-touch-icon" href="assets/favicon.png" />
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Clash+Display:wght@400;500;600&family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <title>Income Calculator</title>
  <script src="pwa.js" defer></script>
  <style>
    :root {
      color-scheme: dark;
      --bg-gradient: radial-gradient(circle at top left, #1e2330, #10131c 55%, #0a0c12 100%);
      --font-body: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      --font-heading: "Clash Display", "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      --card-bg: rgba(20, 24, 35, 0.85);
      --card-border: rgba(255, 255, 255, 0.08);
      --card-border-gradient: linear-gradient(
        135deg,
        rgba(77, 163, 255, 0.6),
        rgba(149, 114, 255, 0.45)
      );
      --card-surface-gradient: linear-gradient(
        160deg,
        rgba(255, 255, 255, 0.08),
        rgba(255, 255, 255, 0.02)
      );
      --card-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      --accent: #4da3ff;
      --text-primary: #f5f7fb;
      --text-muted: #b1b7c7;
      --field-bg: rgba(7, 9, 14, 0.75);
      --field-border: rgba(255, 255, 255, 0.15);
      --field-output-bg: rgba(77, 163, 255, 0.18);
      --field-output-border: rgba(77, 163, 255, 0.5);
      --field-output-color: #e5f1ff;
      --table-header-bg: rgba(255, 255, 255, 0.04);
      --table-header-text: var(--text-muted);
      --table-row-border: rgba(255, 255, 255, 0.07);
      --row-header-bg: rgba(255, 255, 255, 0.02);
      --price-line-bg: rgba(255, 255, 255, 0.03);
      --price-line-border: rgba(255, 255, 255, 0.05);
      --price-buffer-bg: rgba(77, 163, 255, 0.08);
      --price-buffer-border: rgba(77, 163, 255, 0.25);
      --breakdown-color-vat: #f97316;
      --breakdown-color-variable: #8b5cf6;
      --breakdown-color-fixed: #38bdf8;
      --breakdown-color-tax: #ef4444;
      --breakdown-color-net: #22c55e;
      --button-bg: #f1f5ff;
      --button-color: #0c111d;
      --button-shadow: rgba(0, 0, 0, 0.3);
      --secondary-button-bg: rgba(77, 163, 255, 0.15);
      --secondary-button-border: rgba(77, 163, 255, 0.45);
      --secondary-button-hover-bg: rgba(77, 163, 255, 0.25);
      --info-bg: rgba(77, 163, 255, 0.15);
      --info-border: rgba(77, 163, 255, 0.35);
      --info-hover-bg: rgba(77, 163, 255, 0.25);
      --info-hover-border: rgba(77, 163, 255, 0.55);
      --tooltip-bg: rgba(12, 16, 26, 0.95);
      --tooltip-color: var(--text-primary);
      --tooltip-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      --toggle-track: rgba(255, 255, 255, 0.25);
      --toggle-track-border: rgba(255, 255, 255, 0.35);
      --toggle-thumb: var(--accent);
      --toggle-thumb-shadow: rgba(0, 0, 0, 0.35);
      --focus-ring: rgba(77, 163, 255, 0.25);
      --focus-outline: rgba(77, 163, 255, 0.55);
      --inactive-bg: rgba(255, 76, 96, 0.12);
      --inactive-border: rgba(255, 76, 96, 0.45);
      --inactive-text: #ff93a6;
      --inactive-strong: #ffb7c3;
      --active-bg: rgba(77, 163, 255, 0.12);
      --active-border: rgba(77, 163, 255, 0.45);
      --price-out-of-range: #ff7b7b;
      --price-acceptable-bg: rgba(34, 197, 94, 0.18);
      --price-acceptable-border: rgba(34, 197, 94, 0.5);
      --price-acceptable-hover: rgba(34, 197, 94, 0.28);
    }

    body[data-theme="light"] {
      color-scheme: light;
      --bg-gradient: radial-gradient(circle at top left, #eff4ff, #dde7ff 55%, #d4e0ff 100%);
      --font-body: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      --font-heading: "Clash Display", "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      --card-bg: rgba(255, 255, 255, 0.92);
      --card-border: rgba(15, 23, 42, 0.08);
      --card-border-gradient: linear-gradient(
        135deg,
        rgba(37, 99, 235, 0.35),
        rgba(59, 130, 246, 0.15)
      );
      --card-surface-gradient: linear-gradient(
        160deg,
        rgba(255, 255, 255, 0.95),
        rgba(249, 250, 255, 0.85)
      );
      --card-shadow: 0 20px 40px rgba(15, 23, 42, 0.12);
      --accent: #2563eb;
      --text-primary: #111827;
      --text-muted: #4b5563;
      --field-bg: rgba(255, 255, 255, 0.85);
      --field-border: rgba(15, 23, 42, 0.14);
      --field-output-bg: rgba(37, 99, 235, 0.14);
      --field-output-border: rgba(37, 99, 235, 0.35);
      --field-output-color: #0b162d;
      --table-header-bg: rgba(37, 99, 235, 0.08);
      --table-header-text: #1f2937;
      --table-row-border: rgba(15, 23, 42, 0.08);
      --row-header-bg: rgba(226, 232, 240, 0.6);
      --price-line-bg: rgba(15, 23, 42, 0.04);
      --price-line-border: rgba(15, 23, 42, 0.1);
      --price-buffer-bg: rgba(37, 99, 235, 0.12);
      --price-buffer-border: rgba(37, 99, 235, 0.28);
      --breakdown-color-vat: #ea580c;
      --breakdown-color-variable: #7c3aed;
      --breakdown-color-fixed: #2563eb;
      --breakdown-color-tax: #dc2626;
      --breakdown-color-net: #16a34a;
      --button-bg: #1d4ed8;
      --button-color: #f8fafc;
      --button-shadow: rgba(29, 78, 216, 0.3);
      --secondary-button-bg: rgba(37, 99, 235, 0.12);
      --secondary-button-border: rgba(37, 99, 235, 0.3);
      --secondary-button-hover-bg: rgba(37, 99, 235, 0.22);
      --info-bg: rgba(37, 99, 235, 0.12);
      --info-border: rgba(37, 99, 235, 0.32);
      --info-hover-bg: rgba(37, 99, 235, 0.2);
      --info-hover-border: rgba(37, 99, 235, 0.45);
      --tooltip-bg: rgba(15, 23, 42, 0.95);
      --tooltip-color: #f8fafc;
      --tooltip-shadow: 0 18px 36px rgba(15, 23, 42, 0.24);
      --toggle-track: rgba(15, 23, 42, 0.12);
      --toggle-track-border: rgba(15, 23, 42, 0.22);
      --toggle-thumb: #1d4ed8;
      --toggle-thumb-shadow: rgba(15, 23, 42, 0.25);
      --focus-ring: rgba(37, 99, 235, 0.28);
      --focus-outline: rgba(37, 99, 235, 0.55);
      --inactive-bg: rgba(239, 68, 68, 0.12);
      --inactive-border: rgba(220, 38, 38, 0.35);
      --inactive-text: #c53030;
      --inactive-strong: #e53e3e;
      --active-bg: rgba(37, 99, 235, 0.12);
      --active-border: rgba(37, 99, 235, 0.35);
      --price-out-of-range: #b91c1c;
      --price-acceptable-bg: rgba(34, 197, 94, 0.14);
      --price-acceptable-border: rgba(34, 197, 94, 0.32);
      --price-acceptable-hover: rgba(34, 197, 94, 0.22);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: var(--font-body);
      line-height: 1.65;
      background: var(--bg-gradient);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      transition: background 0.4s ease, color 0.4s ease;
      overflow-x: hidden;
      touch-action: pan-y;
    }

    body.dialog-open {
      overflow: hidden;
    }

    body[data-theme="dark"] {
      color-scheme: dark;
    }

    h1,
    h2 {
      font-family: var(--font-heading);
      font-weight: 500;
      letter-spacing: -0.01em;
      line-height: 1.15;
      margin: 0;
    }

    a {
      color: inherit;
    }

    .visually-hidden {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0 0 0 0);
      white-space: nowrap;
      border: 0;
    }

    .top-nav {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 8px 0 0;
    }

    .top-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--secondary-button-border);
      background: var(--secondary-button-bg);
      color: var(--text-primary);
      font-size: 0.95rem;
      text-decoration: none;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }

    .top-link::before {
      content: "📘";
      font-size: 1rem;
    }

    .top-link:hover,
    .top-link:focus-visible {
      background: var(--secondary-button-hover-bg);
      border-color: var(--secondary-button-border);
      transform: translateY(-1px);
      outline: none;
      box-shadow: 0 0 0 3px var(--focus-ring);
    }

    .readme-dialog[hidden] {
      display: none;
    }

    .readme-dialog {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .readme-dialog__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
    }

    .readme-dialog__content {
      position: relative;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 18px;
      box-shadow: 0 35px 70px var(--card-shadow);
      max-width: min(960px, 92vw);
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .readme-dialog__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 24px;
      border-bottom: 1px solid var(--table-row-border);
      background: var(--row-header-bg);
    }

    .readme-dialog__close {
      appearance: none;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 6px;
      border-radius: 50%;
      line-height: 1;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .readme-dialog__close:hover,
    .readme-dialog__close:focus-visible {
      background: var(--secondary-button-bg);
      color: var(--text-primary);
      outline: none;
      box-shadow: 0 0 0 3px var(--focus-ring);
    }

    .readme-dialog__body {
      padding: 24px;
      overflow-y: auto;
      line-height: 1.6;
      color: var(--text-primary);
      background: var(--field-output-bg);
    }

    .readme-dialog__body h1,
    .readme-dialog__body h2,
    .readme-dialog__body h3,
    .readme-dialog__body h4,
    .readme-dialog__body h5,
    .readme-dialog__body h6 {
      color: var(--text-primary);
      margin-top: 1.4em;
    }

    .readme-dialog__body p,
    .readme-dialog__body li {
      color: var(--text-muted);
    }

    .readme-dialog__body pre {
      background: rgba(0, 0, 0, 0.4);
      padding: 12px 14px;
      border-radius: 12px;
      overflow-x: auto;
      border: 1px solid var(--table-row-border);
    }

    .readme-dialog__body code {
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
    }

    .readme-dialog__body a {
      color: var(--accent);
    }

    .readme-dialog__body ul,
    .readme-dialog__body ol {
      padding-left: 1.25em;
    }

    .readme-dialog__body table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5em 0;
    }

    .readme-dialog__body th,
    .readme-dialog__body td {
      border: 1px solid var(--table-row-border);
      padding: 8px 12px;
    }

    .readme-dialog__body blockquote {
      border-left: 3px solid var(--accent);
      margin: 1.2em 0;
      padding: 0.5em 1em;
      color: var(--text-muted);
      background: rgba(0, 0, 0, 0.25);
      border-radius: 12px;
    }

    .readme-status {
      margin: 0;
      color: var(--text-muted);
    }

    .readme-status--error {
      color: var(--inactive-strong);
    }

    @media (max-width: 720px) {
      .top-nav {
        justify-content: center;
      }

      .top-link {
        width: 100%;
        justify-content: center;
      }

      .readme-dialog__content {
        width: 92vw;
        max-height: 92vh;
      }
    }

    .accounting-dialog[hidden] {
      display: none;
    }

    .accounting-dialog {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1100;
    }

    .accounting-dialog__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
    }

    .accounting-dialog__content {
      position: relative;
      width: min(520px, 92vw);
      max-height: 92vh;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 18px;
      box-shadow: 0 35px 70px var(--card-shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .accounting-dialog__header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 18px;
      padding: 20px 24px 16px;
      border-bottom: 1px solid var(--table-row-border);
      background: var(--row-header-bg);
    }

    .accounting-dialog__title {
      margin: 0;
      font-size: 1.35rem;
    }

    .accounting-dialog__subtitle {
      margin: 6px 0 0;
      color: var(--text-muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .accounting-dialog__close {
      appearance: none;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 6px;
      border-radius: 50%;
      line-height: 1;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .accounting-dialog__close:hover,
    .accounting-dialog__close:focus-visible {
      background: var(--secondary-button-bg);
      color: var(--text-primary);
      outline: none;
      box-shadow: 0 0 0 3px var(--focus-ring);
    }

    .accounting-dialog__form {
      flex: 1;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      overflow-y: auto;
    }

    .accounting-dialog__field label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .accounting-dialog__field input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--field-border);
      background: var(--field-bg);
      color: var(--text-primary);
      font-size: 1rem;
      padding: 10px 12px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .accounting-dialog__field input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--focus-ring);
      background: var(--field-output-bg);
    }

    .accounting-dialog__note {
      margin: 0;
      color: var(--text-muted);
      font-size: 0.92rem;
      line-height: 1.5;
    }

    .accounting-dialog__error {
      margin: 0;
      min-height: 1.1em;
      color: var(--price-out-of-range);
      font-weight: 600;
      font-size: 0.95rem;
    }

    .accounting-dialog__actions {
      margin-top: auto;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }

    .accounting-dialog__actions button {
      min-width: 120px;
    }

    @media (max-width: 720px) {
      .accounting-dialog {
        padding: 16px;
      }

      .accounting-dialog__content {
        width: min(480px, 96vw);
      }

      .accounting-dialog__form {
        padding: 20px;
      }
    }

    .lesson-breakdown-dialog[hidden] {
      display: none;
    }

    .lesson-breakdown-dialog {
      position: fixed;
      inset: 0;
      z-index: 950;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(16px, 4vw, 32px);
    }

    .lesson-breakdown-dialog__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(8, 11, 20, 0.6);
      backdrop-filter: blur(6px);
    }

    .lesson-breakdown-dialog__content {
      position: relative;
      z-index: 1;
      width: min(960px, 100%);
      max-height: 92vh;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 20px;
      box-shadow: var(--card-shadow);
      padding: clamp(20px, 3vw, 28px);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .lesson-breakdown-dialog__header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
    }

    .lesson-breakdown-dialog__header h2 {
      margin: 0;
      font-size: clamp(1.4rem, 2vw, 1.65rem);
    }

    .lesson-breakdown-dialog__variant {
      margin: 6px 0 0;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .lesson-breakdown-dialog__summary {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .lesson-breakdown-dialog__price {
      margin: 0;
      font-size: clamp(1.4rem, 2.4vw, 1.75rem);
      font-weight: 600;
    }

    .lesson-breakdown-dialog__meta,
    .lesson-breakdown-dialog__total {
      margin: 0;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .lesson-breakdown-dialog__body {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(220px, 280px);
      gap: clamp(18px, 3vw, 28px);
    }

    .lesson-breakdown-dialog__table-wrapper {
      overflow: auto;
      border-radius: 16px;
      border: 1px solid var(--table-row-border);
      background: var(--field-output-bg);
    }

    .lesson-breakdown-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 320px;
    }

    .lesson-breakdown-table thead th {
      position: sticky;
      top: 0;
      background: var(--table-header-bg);
      color: var(--table-header-text);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.75rem;
      padding: 12px;
    }

    .lesson-breakdown-table th,
    .lesson-breakdown-table td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--table-row-border);
      font-size: 0.95rem;
    }

    .lesson-breakdown-table tbody th {
      text-align: left;
      font-weight: 600;
    }

    .lesson-breakdown-table tbody td {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .lesson-breakdown-table tbody tr:last-child th,
    .lesson-breakdown-table tbody tr:last-child td {
      border-bottom: none;
    }

    .lesson-breakdown-dialog__chart {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 16px;
    }

    .lesson-breakdown-dialog__chart-graphic {
      width: clamp(160px, 22vw, 200px);
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      background: var(--price-line-bg);
      border: 1px solid var(--price-line-border);
      margin: 0 auto;
      position: relative;
      transition: background 0.3s ease;
    }

    .lesson-breakdown-dialog__chart-graphic::after {
      content: "";
      position: absolute;
      inset: 24%;
      border-radius: 50%;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
    }

    .lesson-breakdown-dialog__legend {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .lesson-breakdown-dialog__legend-item {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 0.9rem;
    }

    .lesson-breakdown-dialog__legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--swatch-color, var(--accent));
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.2);
      flex: 0 0 auto;
    }

    .lesson-breakdown-dialog__legend-label {
      flex: 1 1 auto;
      color: var(--text-muted);
    }

    .lesson-breakdown-dialog__legend-value {
      flex: 0 0 auto;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }

    .lesson-breakdown-dialog__close {
      appearance: none;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 6px;
      border-radius: 50%;
      line-height: 1;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .lesson-breakdown-dialog__close:hover,
    .lesson-breakdown-dialog__close:focus-visible {
      background: var(--secondary-button-bg);
      color: var(--text-primary);
      outline: none;
      box-shadow: 0 0 0 3px var(--focus-ring);
    }

    @media (max-width: 900px) {
      .lesson-breakdown-dialog__body {
        grid-template-columns: 1fr;
      }

      .lesson-breakdown-dialog__chart {
        align-items: center;
      }
    }

    @media (max-width: 540px) {
      .lesson-breakdown-dialog__content {
        border-radius: 16px;
        padding: 18px;
      }

      .lesson-breakdown-dialog__body {
        gap: 18px;
      }

      .lesson-breakdown-dialog__table-wrapper {
        border-radius: 12px;
      }
    }

    .page {
      position: relative;
      overflow: visible;
      isolation: isolate;
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: clamp(16px, 3vw, 32px);
      padding-top: calc(
        clamp(16px, 3vw, 32px) + env(safe-area-inset-top, 0px)
      );
      gap: clamp(16px, 2vw, 24px);
    }

    .page::before {
      content: "";
      position: absolute;
      inset: -40% -20% -60%;
      background: radial-gradient(
          circle at 30% 20%,
          rgba(77, 163, 255, 0.25),
          transparent 55%
        ),
        radial-gradient(circle at 70% 30%, rgba(149, 114, 255, 0.2), transparent 50%),
        radial-gradient(circle at 50% 80%, rgba(77, 163, 255, 0.18), transparent 55%);
      opacity: 0.45;
      filter: blur(0);
      transform: scale(1.05);
      animation: page-backdrop-drift 26s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    @keyframes page-backdrop-drift {
      0% {
        transform: scale(1.05) translate3d(-6%, -3%, 0) rotate(0deg);
      }

      50% {
        transform: scale(1.05) translate3d(8%, 6%, 0) rotate(5deg);
      }

      100% {
        transform: scale(1.05) translate3d(-6%, -3%, 0) rotate(0deg);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .page::before {
        animation: none;
      }
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 16px;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .persist-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 14px 16px;
      border-radius: 14px;
      border: 1px solid var(--field-border);
      background: var(--field-output-bg);
      width: 100%;
    }

    .persist-controls__primary {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1 1 60%;
    }

    .persist-checkbox {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .persist-checkbox input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      accent-color: var(--accent);
    }

    .persist-description {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .persist-controls button {
      flex: 0 0 auto;
      min-width: 150px;
    }

    .header-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 9px 16px;
      border-radius: 999px;
      border: 1px solid var(--secondary-button-border);
      background: var(--secondary-button-bg);
      color: inherit;
      font-weight: 500;
      text-decoration: none;
      transition: background 0.25s ease, border-color 0.25s ease, transform 0.2s ease;
    }

    .header-link:hover,
    .header-link:focus-visible {
      background: var(--secondary-button-hover-bg);
      border-color: var(--secondary-button-border);
      transform: translateY(-1px);
    }

    .header-link:focus-visible {
      outline: 3px solid var(--focus-outline);
      outline-offset: 2px;
    }

    .header-text {
      flex: 1 1 340px;
      min-width: 240px;
      max-width: 720px;
    }

    .header-text p {
      color: var(--text-muted);
      margin: 8px 0 0;
    }

    .layout {
      display: flex;
      gap: 24px;
      flex: 1;
      min-height: 0;
    }

    .card {
      position: relative;
      z-index: 0;
      border-radius: 18px;
      padding: clamp(16px, 2vw, 24px);
      box-shadow: var(--card-shadow);
      backdrop-filter: blur(16px);
      overflow: visible;
      transform: translateY(0);
      transition: transform 0.35s ease, box-shadow 0.4s ease, color 0.4s ease, background 0.4s ease;
    }

    .card::before,
    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
    }

    .card::before {
      padding: 1px;
      background: var(--card-border-gradient);
      opacity: 0.75;
      z-index: -2;
      transition: opacity 0.45s ease;
      -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      mask-composite: exclude;
    }

    .card::after {
      z-index: -1;
      background: var(--card-bg);
      background-image: var(--card-surface-gradient);
      opacity: 0.95;
      transition: opacity 0.45s ease;
    }

    .card:hover,
    .card:focus-within {
      transform: translateY(-4px);
      box-shadow: var(--card-shadow), 0 18px 36px rgba(77, 163, 255, 0.12);
      z-index: 2;
    }

    .card:hover::before,
    .card:focus-within::before {
      opacity: 1;
    }

    .card:hover::after,
    .card:focus-within::after {
      opacity: 1;
    }

    .privacy-info {
      display: flex;
      flex-direction: column;
      gap: 16px;
      line-height: 1.6;
    }

    .privacy-info h2,
    .privacy-info h3 {
      margin: 0;
    }

    .privacy-info h3 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-muted);
    }

    .privacy-info ol {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 12px;
    }

    .privacy-info li {
      padding-left: 4px;
    }

    .controls {
      flex: 0 0 320px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .controls .control-sections,
    .controls .control-section {
      border: none;
      padding: 0;
      margin: 0;
    }

    .controls .control-sections {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .controls .control-section {
      border: 1px solid var(--card-border);
      border-radius: 16px;
      background: var(--card-surface-gradient);
      padding: 16px 18px 18px;
    }

    .section-legend {
      margin: 0;
      padding: 0;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 0 6px;
      width: 100%;
    }

    .section-title {
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      flex: 1 1 auto;
      min-width: 0;
    }

    .section-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 6px 12px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      border-radius: 999px;
      border: 1px solid var(--secondary-button-border);
      background: var(--secondary-button-bg);
      color: var(--text-primary);
      box-shadow: none;
      transform: none;
      white-space: nowrap;
    }

    .section-toggle:hover,
    .section-toggle:focus-visible {
      background: var(--secondary-button-hover-bg);
      border-color: var(--secondary-button-border);
      color: var(--text-primary);
      box-shadow: none;
      transform: none;
    }

    .section-toggle--top {
      flex: 0 0 auto;
    }

    .section-toggle--bottom {
      margin-top: 8px;
    }

    .section-footer {
      display: flex;
      justify-content: flex-end;
      margin-top: 4px;
    }

    .controls .control-section.collapsed .section-body {
      display: none;
    }

    .controls .control-section.collapsed .section-footer {
      display: none;
    }

    .controls .control-section .section-body {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 12px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 0;
      border-radius: 14px;
      border: 1px solid transparent;
      background: transparent;
      transition: border-color 0.3s ease, background-color 0.3s ease, padding 0.3s ease;
    }

    .desired-income-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .desired-income-actions .secondary {
      flex: 1 1 200px;
      min-width: 160px;
      justify-content: center;
    }

    .acceptable-income-group {
      gap: 14px;
      padding: 16px;
      background: var(--field-bg);
      border: 1px solid var(--field-border);
    }

    .acceptable-income-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
    }

    .acceptable-income-header .label-text {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .acceptable-income-header .sub-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-muted);
    }

    .acceptable-income-basis {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .acceptable-income-basis__option {
      position: relative;
      display: inline-flex;
      align-items: center;
      cursor: pointer;
    }

    .acceptable-income-basis__option input {
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
    }

    .acceptable-income-basis__option span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--secondary-button-border);
      background: var(--secondary-button-bg);
      color: var(--text-muted);
      font-size: 0.85rem;
      font-weight: 500;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }

    .acceptable-income-basis__option input:checked + span {
      color: var(--text-primary);
      border-color: var(--secondary-button-border);
      background: var(--secondary-button-hover-bg);
    }

    .acceptable-income-inputs {
      gap: 12px;
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control.control-panel {
      gap: 12px;
      padding: 16px;
      border-radius: 14px;
      border: 1px solid var(--field-border);
      background: var(--field-output-bg);
    }

    .control--nested {
      gap: 6px;
    }

    .control--fixed-costs {
      gap: 12px;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .inline-field-pair {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      align-items: end;
    }

    .inline-field-pair label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.85rem;
    }

    .panel-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .fixed-costs-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .fixed-costs-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .fixed-cost-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: flex-start;
    }

    .fixed-cost-label {
      flex: 1 1 180px;
      font-weight: 500;
    }

    .fixed-cost-inputs {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 12px;
      flex: 2 1 280px;
    }

    .fixed-cost-inputs label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.85rem;
    }

    .input-label {
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.75rem;
    }

    .custom-costs {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 16px;
      border-radius: 12px;
      border: 1px dashed var(--field-border);
      background: var(--field-bg);
    }

    .custom-costs__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .custom-costs__form {
      display: grid;
      grid-template-columns: minmax(160px, 2fr) minmax(120px, 1fr) minmax(120px, 1fr) auto;
      gap: 10px;
      align-items: end;
    }

    .custom-costs__form input,
    .custom-costs__form select {
      width: 100%;
    }

    .custom-costs__form button {
      align-self: stretch;
      padding: 10px 14px;
    }

    .custom-costs__list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .custom-costs__item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--field-border);
      background: var(--field-bg);
    }

    .custom-costs__item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .custom-costs__item button {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--field-border);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }

    .custom-costs__item button:hover,
    .custom-costs__item button:focus-visible {
      color: var(--text-primary);
      border-color: var(--secondary-button-border);
      background: var(--secondary-button-bg);
    }

    .fixed-cost-total {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-top: 8px;
      border-top: 1px solid var(--field-border);
    }

    .fixed-cost-total input[readonly] {
      cursor: default;
      background: var(--field-output-bg);
    }

    label {
      font-size: 0.95rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .field-note,
    .field-message {
      font-size: 0.85rem;
      margin: 0;
      color: var(--text-muted);
    }

    .field-message:empty {
      display: none;
    }

    .label-text {
      flex: 1 1 auto;
      min-width: 0;
    }

    .info-icon {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.5rem;
      height: 1.5rem;
      border-radius: 999px;
      font-size: 0.9rem;
      background: var(--info-bg);
      color: var(--accent);
      cursor: pointer;
      border: 1px solid var(--info-border);
      flex: 0 0 auto;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      touch-action: manipulation;
      --tooltip-shift: 0px;
    }

    .info-icon:hover,
    .info-icon:focus-visible,
    .info-icon.is-active {
      background: var(--info-hover-bg);
      border-color: var(--info-hover-border);
      outline: none;
      color: #fff;
      box-shadow: 0 0 0 3px var(--focus-ring);
    }

    .info-icon__tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translate(calc(-50% + var(--tooltip-shift, 0px)), 4px);
      width: clamp(180px, calc(100vw - 32px), 260px);
      padding: 10px 12px;
      border-radius: 12px;
      background: var(--tooltip-bg);
      color: var(--tooltip-color);
      font-size: 0.8rem;
      line-height: 1.35;
      box-shadow: var(--tooltip-shadow);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 10;
    }

    .info-icon__arrow {
      position: absolute;
      bottom: calc(100% + 4px);
      left: 50%;
      transform: translate(calc(-50% + var(--tooltip-shift, 0px)), 4px);
      border-width: 6px;
      border-style: solid;
      border-color: var(--tooltip-bg) transparent transparent transparent;
      opacity: 0;
      transition: opacity 0.15s ease, transform 0.15s ease;
      pointer-events: none;
    }

    .info-icon:hover .info-icon__tooltip,
    .info-icon:focus-visible .info-icon__tooltip,
    .info-icon.is-active .info-icon__tooltip,
    .info-icon:hover .info-icon__arrow,
    .info-icon:focus-visible .info-icon__arrow,
    .info-icon.is-active .info-icon__arrow {
      opacity: 1;
      transform: translate(calc(-50% + var(--tooltip-shift, 0px)), 0);
    }

    input[type="number"],
    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--field-border);
      background: var(--field-bg);
      color: inherit;
      font-size: 1rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.3s ease;
    }

    input[type="number"]:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--focus-ring);
    }

    .control output {
      display: block;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 1rem;
      font-variant-numeric: tabular-nums;
    }

    .output-field {
      border: 1px solid var(--field-output-border);
      background: var(--field-output-bg);
      color: var(--field-output-color);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease, color 0.2s ease;
      color: var(--button-color);
      background: var(--button-bg);
    }

    button:focus-visible {
      outline: 3px solid var(--focus-outline);
      outline-offset: 2px;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px var(--button-shadow);
    }

    button.secondary {
      background: var(--secondary-button-bg);
      color: var(--text-primary);
      border: 1px solid var(--secondary-button-border);
    }

    button.secondary:hover {
      background: var(--secondary-button-hover-bg);
    }

    .theme-toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 6px 14px 6px 10px;
      background: var(--card-bg);
      color: var(--text-primary);
      border: 1px solid var(--card-border);
      border-radius: 999px;
      font-size: 0.9rem;
      font-weight: 600;
      transform: none;
      box-shadow: none;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    .theme-toggle:hover,
    .theme-toggle:focus-visible {
      transform: none;
      box-shadow: 0 0 0 3px var(--focus-ring);
      background: var(--secondary-button-bg);
      border-color: var(--secondary-button-border);
    }

    .theme-toggle .toggle-track {
      position: relative;
      width: 40px;
      height: 22px;
      border-radius: 999px;
      background: var(--toggle-track);
      border: 1px solid var(--toggle-track-border);
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 6px;
      transition: background 0.3s ease, border-color 0.3s ease;
    }

    .theme-toggle .toggle-track::before,
    .theme-toggle .toggle-track::after {
      font-size: 0.7rem;
      line-height: 1;
      opacity: 0.65;
    }

    .theme-toggle .toggle-track::before {
      content: '🌙';
    }

    .theme-toggle .toggle-track::after {
      content: '☀️';
    }

    body[data-theme="dark"] .theme-toggle .toggle-track::before {
      opacity: 1;
    }

    body[data-theme="dark"] .theme-toggle .toggle-track::after {
      opacity: 0.45;
    }

    body[data-theme="light"] .theme-toggle .toggle-track::before {
      opacity: 0.45;
    }

    body[data-theme="light"] .theme-toggle .toggle-track::after {
      opacity: 1;
    }

    .theme-toggle .toggle-thumb {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background: var(--toggle-thumb);
      box-shadow: 0 2px 6px var(--toggle-thumb-shadow);
      transition: transform 0.3s ease;
    }

    body[data-theme="dark"] .theme-toggle .toggle-thumb {
      transform: translateX(0);
    }

    body[data-theme="light"] .theme-toggle .toggle-thumb {
      transform: translateX(20px);
    }

    .theme-toggle .toggle-label {
      font-size: 0.85rem;
      font-weight: 600;
    }

    .tables {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 24px;
      min-width: 0;
    }

    .variable-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: flex-end;
      margin-bottom: 4px;
    }

    .variable-controls .variable-control {
      flex: 1 1 220px;
      min-width: 200px;
    }

    .variable-controls .variable-control select {
      width: 100%;
    }

    .variable-controls__reset {
      display: flex;
      align-items: flex-end;
    }

    .variable-controls__reset button {
      padding: 10px 16px;
    }

    .table-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
    }

    .table-grid.table-grid--stacked {
      grid-template-columns: minmax(0, 1fr);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-variant-numeric: tabular-nums;
      border-radius: 14px;
      overflow: visible;
    }

    caption {
      text-align: left;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 12px;
    }

    thead th {
      background: var(--table-header-bg);
      padding: 10px 12px;
      text-align: left;
      font-size: 0.9rem;
      color: var(--table-header-text);
    }

    thead th:not(:first-child) {
      text-align: center;
    }

    tbody th,
    tbody td {
      padding: 10px 12px;
      border-top: 1px solid var(--table-row-border);
    }

    tbody th {
      text-align: left;
      font-weight: 600;
      background: var(--row-header-bg);
      color: var(--text-primary);
    }

    tbody td {
      text-align: left;
      line-height: 1.5;
      white-space: normal;
    }

    .price-pair {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-start;
    }

    .price-cell-empty {
      color: var(--text-muted);
      font-style: italic;
    }

    .income-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4px 12px;
      width: 100%;
      margin-top: 6px;
    }

    .income-grid__item {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
    }

    .income-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--text-muted);
    }

    .income-value {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    .price-line {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
      padding: 8px 10px;
      border-radius: 10px;
      background: var(--price-line-bg);
      border: 1px solid var(--price-line-border);
      color: inherit;
      transition: border-color 0.2s ease, background-color 0.2s ease,
        transform 0.2s ease, box-shadow 0.2s ease;
    }

    .price-line strong {
      font-size: 1.05rem;
    }

    .price-line .price-label {
      font-size: 0.75rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .price-line .price-secondary {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .price-line .price-tertiary {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .price-value--out-of-range {
      color: var(--price-out-of-range) !important;
    }

    .price-line--out-of-range .price-secondary {
      color: var(--price-out-of-range) !important;
    }

    .price-line.buffered {
      background: var(--price-buffer-bg);
      border-color: var(--price-buffer-border);
    }

    .price-line.base {
      display: none;
      margin-top: 8px;
      border-style: dashed;
    }

    button.price-line {
      width: 100%;
      text-align: left;
      cursor: pointer;
      background: var(--price-line-bg);
      border-radius: 10px;
      border: 1px solid var(--price-line-border);
      color: inherit;
      font: inherit;
      line-height: inherit;
      padding: 8px 10px;
    }

    button.price-line:focus {
      outline: none;
    }

    button.price-line:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    button.price-line:focus-visible {
      outline: 2px solid var(--focus-outline);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px var(--focus-ring);
    }

    button.price-line.price-line--acceptable {
      background: var(--price-acceptable-bg);
      border-color: var(--price-acceptable-border);
    }

    button.price-line.price-line--acceptable:hover {
      background: var(--price-acceptable-hover);
      border-color: var(--price-acceptable-border);
    }

    button.price-line.price-line--acceptable:focus-visible {
      background: var(--price-acceptable-hover);
      border-color: var(--price-acceptable-border);
    }

    .pricing-card.show-base-prices .price-line.base {
      display: flex;
    }

    .price-toggle-row {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 12px;
    }

    .price-reveal-toggle {
      padding: 6px 12px;
      font-size: 0.8rem;
    }

    .sub-label {
      display: block;
      font-size: 0.75rem;
      color: var(--text-muted);
      font-weight: 400;
      margin-top: 2px;
    }

    .tables .card {
      min-height: 100%;
      overflow: visible;
    }

    .card-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x pan-y;
      overscroll-behavior-x: contain;
    }

    .card-scroll table {
      min-width: 100%;
      width: max-content;
    }

    ul.assumptions {
      margin: 0;
      padding-left: 20px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .tables-footer {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .status-message {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    @media (max-width: 720px) {
      header {
        flex-direction: column;
        align-items: stretch;
        text-align: center;
      }

      .header-text {
        flex: 1 1 auto;
        text-align: center;
      }

      .theme-toggle {
        align-self: center;
      }

      .persist-controls {
        flex-direction: column;
        align-items: stretch;
        text-align: left;
      }

      .persist-controls button {
        width: 100%;
      }

      .layout {
        gap: 16px;
      }

      .controls {
        gap: 16px;
      }

      .controls .control-sections {
        order: 1;
      }

      .controls .actions {
        order: 2;
      }

      .controls .status-message {
        order: 3;
      }
    }

    @media (max-width: 960px) {
      .layout {
        flex-direction: column;
      }

      .controls {
        flex-basis: auto;
      }
    }

    @media (max-width: 720px) {
      .header-actions {
        width: 100%;
        justify-content: center;
        gap: 10px;
      }

      .fixed-cost-row {
        gap: 10px;
      }

      .fixed-cost-inputs {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 8px;
      }
    }

    @media (max-width: 520px) {
      .fixed-cost-row {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .fixed-cost-label,
      .fixed-cost-inputs {
        flex: 1 1 auto;
        min-height: auto;
        width: 100%;
      }

      .fixed-cost-inputs {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 520px) {
      .section-header {
        align-items: flex-start;
        flex-direction: column;
        gap: 8px;
      }

      .section-toggle--top {
        align-self: flex-end;
      }

      button:not(.section-toggle) {
        width: 100%;
        justify-content: center;
      }

      .button-row {
        flex-direction: column;
      }

      tbody td {
        white-space: normal;
      }
    }
  </style>
</head>
<body data-theme="dark">
  <div class="page">
    <nav class="top-nav">
      <a href="resources.html" class="top-link">Helpful Resources</a>
      <a href="#" id="how-to-link" class="top-link">How To Use This Tool</a>
    </nav>
    <header>
      <div class="header-text">
        <h1>Income Calculator</h1>
        <p>Estimate per-student pricing to reach your target income. All calculations stay on this page.</p>
      </div>
      <div class="header-actions">
        <a class="header-link" href="#privacy-info">Your Info Is Safe</a>
        <button type="button" class="theme-toggle" id="theme-toggle" aria-pressed="true">
          <span class="toggle-track" aria-hidden="true">
            <span class="toggle-thumb"></span>
          </span>
          <span class="toggle-label">Dark mode</span>
        </button>
      </div>
    </header>

    <div class="layout">
      <section class="card controls" aria-labelledby="inputs-heading">
        <h2 id="inputs-heading" style="font-size: 1.1rem;">Inputs</h2>
        <fieldset class="control-sections">
          <legend class="visually-hidden">Calculator inputs</legend>

          <fieldset class="control-section" data-collapsible>
            <legend class="section-legend visually-hidden" id="section-settings-legend">Settings</legend>
            <div class="section-header">
              <span class="section-title" aria-hidden="true">Settings</span>
              <button
                type="button"
                class="section-toggle section-toggle--top"
                data-expanded-text="Collapse"
                data-collapsed-text="Expand"
                aria-expanded="true"
                aria-controls="section-settings"
              >
                <span class="toggle-label">Collapse</span>
              </button>
            </div>
            <div class="section-body" id="section-settings">
              <div class="persist-controls" role="group" aria-labelledby="persist-settings-label">
                <div class="persist-controls__primary">
                  <label class="persist-checkbox" id="persist-settings-label" for="remember-inputs">
                    <input type="checkbox" id="remember-inputs" />
                    <span>Remember my inputs on this device</span>
                  </label>
                  <p class="persist-description">
                    Stores your latest calculator values in local storage so they're ready the next time you visit from this browser.
                  </p>
                </div>
                <button type="button" id="reset-saved-inputs" class="secondary">Reset to defaults</button>
              </div>
              <div class="control">
                <label for="currency-symbol">
                  <span class="label-text">Currency symbol</span>
                  <span class="info-icon" tabindex="0" role="button" aria-expanded="false" aria-label="Displayed before amounts." data-tooltip="Displayed before amounts.">ℹ️</span>
                </label>
                <input type="text" id="currency-symbol" value="€" maxlength="3" />
              </div>
            </div>
            <div class="section-footer">
              <button
                type="button"
                class="section-toggle section-toggle--bottom"
                data-expanded-text="Collapse section"
                data-collapsed-text="Expand section"
                aria-expanded="true"
                aria-controls="section-settings"
              >
                <span class="toggle-label">Collapse section</span>
              </button>
            </div>
          </fieldset>

          <fieldset class="control-section" data-collapsible>
            <legend class="section-legend visually-hidden" id="section-desired-income-legend">Desired income</legend>
            <div class="section-header">
              <span class="section-title" aria-hidden="true">
                <span id="desired-income-title">Desired Net Income</span>
              </span>
              <button
                type="button"
                class="section-toggle section-toggle--top"
                data-expanded-text="Collapse"
                data-collapsed-text="Expand"
                aria-expanded="true"
                aria-controls="section-desired-income"
              >
                <span class="toggle-label">Collapse</span>
              </button>
            </div>
            <div class="section-body" id="section-desired-income">
              <div class="desired-income-actions" role="group" aria-label="Income display options">
                <button type="button" class="secondary" id="desired-income-toggle-display">
                  Toggle Gross/Net
                </button>
                <button type="button" class="secondary" id="desired-income-toggle-interpretation">
                  Toggle Gross/Net (lock amount)
                </button>
              </div>
              <div class="control-group">
                <p class="field-note">Entering an income value will update the lesson cost automatically.</p>
                <div class="control">
                  <label for="target-net">
                    <span
                      class="label-text"
                      data-net-label="Net income per year"
                      data-gross-label="Gross income per year"
                    >Net income per year</span>
                    <span
                      class="info-icon"
                      tabindex="0"
                      role="button"
                      aria-expanded="false"
                      data-net-tooltip="Amount you want to take home after income taxes."
                      data-gross-tooltip="Income before income taxes needed to reach your desired take-home pay."
                      data-tooltip="Amount you want to take home after income taxes."
                      aria-label="Amount you want to take home after income taxes."
                    >ℹ️</span>
                  </label>
                  <input type="number" id="target-net" value="50000" min="0" step="100" inputmode="decimal" />
                </div>
                <div class="control">
                  <label for="target-net-week">
                    <span
                      class="label-text"
                      data-net-label="Net income per active week"
                      data-gross-label="Gross income per active week"
                    >Net income per active week</span>
                    <span
                      class="info-icon"
                      tabindex="0"
                      role="button"
                      aria-expanded="false"
                      data-net-tooltip="Take-home pay for each active teaching week after income taxes."
                      data-gross-tooltip="Income before taxes earned during each active teaching week."
                      data-tooltip="Take-home pay for each active teaching week after income taxes."
                      aria-label="Take-home pay for each active teaching week after income taxes."
                    >ℹ️</span>
                  </label>
                  <input type="number" id="target-net-week" value="2000" min="0" step="50" inputmode="decimal" />
                </div>
                <div class="control">
                  <label for="target-net-month">
                    <span
                      class="label-text"
                      data-net-label="Net income per active month"
                      data-gross-label="Gross income per active month"
                    >Net income per active month</span>
                    <span
                      class="info-icon"
                      tabindex="0"
                      role="button"
                      aria-expanded="false"
                      data-net-tooltip="Take-home pay for each month you actively teach after income taxes."
                      data-gross-tooltip="Income before taxes for each month you actively teach."
                      data-tooltip="Take-home pay for each month you actively teach after income taxes."
                      aria-label="Take-home pay for each month you actively teach after income taxes."
                    >ℹ️</span>
                  </label>
                  <input type="number" id="target-net-month" value="5000" min="0" step="100" inputmode="decimal" />
                </div>
                <div class="control">
                  <label for="target-net-average-week">
                    <span
                      class="label-text"
                      data-net-label="Average weekly net income"
                      data-gross-label="Average weekly gross income"
                    >Average weekly net income</span>
                    <span
                      class="info-icon"
                      tabindex="0"
                      role="button"
                      aria-expanded="false"
                      data-net-tooltip="Average weekly take-home pay spread across the full year."
                      data-gross-tooltip="Average weekly income before taxes spread across the full year."
                      data-tooltip="Average weekly take-home pay spread across the full year."
                      aria-label="Average weekly take-home pay spread across the full year."
                    >ℹ️</span>
                  </label>
                  <input type="number" id="target-net-average-week" value="961.54" min="0" step="10" inputmode="decimal" />
                </div>
                <div class="control">
                  <label for="target-net-average-month">
                    <span
                      class="label-text"
                      data-net-label="Average monthly net income"
                      data-gross-label="Average monthly gross income"
                    >Average monthly net income</span>
                    <span
                      class="info-icon"
                      tabindex="0"
                      role="button"
                      aria-expanded="false"
                      data-net-tooltip="Average monthly take-home pay spread across the full year."
                      data-gross-tooltip="Average monthly income before taxes spread across the full year."
                      data-tooltip="Average monthly take-home pay spread across the full year."
                      aria-label="Average monthly take-home pay spread across the full year."
                    >ℹ️</span>
                </label>
                <input type="number" id="target-net-average-month" value="4166.67" min="0" step="50" inputmode="decimal" />
              </div>
            </div>
            <div class="control-group acceptable-income-group">
              <div class="acceptable-income-header">
                <span class="label-text">Acceptable income range (optional)</span>
                <span class="sub-label" id="acceptable-income-current-basis">Monthly</span>
              </div>
              <div class="acceptable-income-basis" role="radiogroup" aria-label="Acceptable income period">
                <label class="acceptable-income-basis__option" for="acceptable-income-basis-monthly">
                  <input
                    type="radio"
                    name="acceptable-income-basis"
                    id="acceptable-income-basis-monthly"
                    value="monthly"
                    checked
                  />
                  <span>Monthly</span>
                </label>
                <label class="acceptable-income-basis__option" for="acceptable-income-basis-annual">
                  <input
                    type="radio"
                    name="acceptable-income-basis"
                    id="acceptable-income-basis-annual"
                    value="annual"
                  />
                  <span>Annual</span>
                </label>
              </div>
              <div class="inline-field-pair acceptable-income-inputs">
                <div class="control control--nested">
                  <label for="acceptable-income-min">
                    <span class="label-text">Minimum income</span>
                  </label>
                  <input
                    type="number"
                    id="acceptable-income-min"
                    inputmode="decimal"
                    min="0"
                    step="0.01"
                  />
                </div>
                <div class="control control--nested">
                  <label for="acceptable-income-max">
                    <span class="label-text">Maximum income</span>
                  </label>
                  <input
                    type="number"
                    id="acceptable-income-max"
                    inputmode="decimal"
                    min="0"
                    step="0.01"
                  />
                </div>
              </div>
              <p class="field-note">Leave either value blank if you do not have a minimum or maximum target.</p>
            </div>
            <div class="section-footer">
              <button
                type="button"
                class="section-toggle section-toggle--bottom"
                data-expanded-text="Collapse section"
                data-collapsed-text="Expand section"
                aria-expanded="true"
                aria-controls="section-desired-income"
              >
                  <span class="toggle-label">Collapse section</span>
                </button>
              </div>
            </div>
          </fieldset>

          <fieldset class="control-section" data-collapsible>
            <legend class="section-legend visually-hidden" id="section-safety-margin-legend">Extra safety margin</legend>
            <div class="section-header">
              <span class="section-title" aria-hidden="true">EXTRA SAFETY MARGIN</span>
              <button
                type="button"
                class="section-toggle section-toggle--top"
                data-expanded-text="Collapse"
                data-collapsed-text="Expand"
                aria-expanded="true"
                aria-controls="section-safety-margin"
              >
                <span class="toggle-label">Collapse</span>
              </button>
            </div>
            <div class="section-body" id="section-safety-margin">
              <p class="field-note">
                This % adds an extra percentage cushion <strong>on top of your desired specified income</strong>. The "buffered" row in the results table uses this value to suggest a lesson price that covers surprises.
              </p>
              <div class="control">
                <label for="buffer">
                  <span class="label-text">Extra safety margin (%)</span>
                  <span
                    class="info-icon"
                    tabindex="0"
                    role="button"
                    aria-expanded="false"
                    aria-label="Adds an extra cushion on top of your desired income. The buffered pricing line uses this percentage."
                    data-tooltip="Adds an extra cushion on top of your desired income. The buffered pricing line uses this percentage."
                  >ℹ️</span>
                </label>
                <input type="number" id="buffer" value="15" min="0" step="1" inputmode="decimal" />
              </div>
            </div>
            <div class="section-footer">
              <button
                type="button"
                class="section-toggle section-toggle--bottom"
                data-expanded-text="Collapse section"
                data-collapsed-text="Expand section"
                aria-expanded="true"
                aria-controls="section-safety-margin"
              >
                <span class="toggle-label">Collapse section</span>
              </button>
            </div>
          </fieldset>

          <fieldset class="control-section" data-collapsible>
            <legend class="section-legend visually-hidden" id="section-taxes-costs-legend">Taxes and costs</legend>
            <div class="section-header">
              <span class="section-title" aria-hidden="true">Taxes and costs</span>
              <button
                type="button"
                class="section-toggle section-toggle--top"
                data-expanded-text="Collapse"
                data-collapsed-text="Expand"
                aria-expanded="true"
                aria-controls="section-taxes-costs"
              >
                <span class="toggle-label">Collapse</span>
              </button>
            </div>
            <div class="section-body" id="section-taxes-costs">
              <div
                class="control control-panel control--taxes"
                role="group"
                aria-labelledby="taxes-group-label"
              >
                <div class="panel-header" id="taxes-group-label">
                  <span class="label-text">Tax rates</span>
                </div>
                <div class="inline-field-pair">
                  <div class="control control--nested">
                    <label for="tax-rate">
                      <span class="label-text">Effective income tax rate (%)</span>
                      <span
                        class="info-icon"
                        tabindex="0"
                        role="button"
                        aria-expanded="false"
                        aria-label="Share of profit paid in taxes and social charges."
                        data-tooltip="Share of profit paid in taxes and social charges."
                      >ℹ️</span>
                    </label>
                    <input type="number" id="tax-rate" value="40" min="0" max="99" step="1" inputmode="decimal" />
                  </div>
                  <div class="control control--nested">
                    <label for="vat-rate">
                      <span class="label-text">VAT/ BTW (%)</span>
                      <span
                        class="info-icon"
                        tabindex="0"
                        role="button"
                        aria-expanded="false"
                        aria-label="Modify if the services you offer fall into a lower VAT band."
                        data-tooltip="Modify if the services you offer fall into a lower VAT band."
                      >ℹ️</span>
                    </label>
                    <input type="number" id="vat-rate" value="21" min="0" step="0.1" inputmode="decimal" />
                  </div>
                </div>
              </div>
              <div class="control control--fixed-costs">
                <div class="fixed-costs-header">
                  <span class="label-text">Fixed costs</span>
                  <span
                    class="info-icon"
                    tabindex="0"
                    role="button"
                    aria-expanded="false"
                    aria-label="Break down ongoing expenses like venue, insurance, pension, health cover, marketing, materials, and admin."
                    data-tooltip="Break down ongoing expenses like venue, insurance, pension, health cover, marketing, materials, and admin."
                  >ℹ️</span>
                </div>
                <p class="field-note">
                  Enter either the monthly or annual amount for each category. The other column updates automatically. Think about rent, business insurance, disability cover (AOV), pension contributions, health insurance, marketing, materials, software, and training.
                </p>
                <div class="fixed-costs-grid">
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Location / venue</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-location-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-location-monthly" value="650" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-location-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-location-annual" value="7800" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Business insurance</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-insurance-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-insurance-monthly" value="100" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-insurance-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-insurance-annual" value="1200" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Disability insurance (AOV)</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-disability-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-disability-monthly" value="220" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-disability-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-disability-annual" value="2640" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Health insurance premium</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-health-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-health-monthly" value="150" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-health-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-health-annual" value="1800" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Pension contributions</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-pension-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-pension-monthly" value="250" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-pension-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-pension-annual" value="3000" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Marketing</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-marketing-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-marketing-monthly" value="300" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-marketing-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-marketing-annual" value="3600" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Materials</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-materials-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-materials-monthly" value="150" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-materials-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-materials-annual" value="1800" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Admin / software</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-admin-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-admin-monthly" value="175" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-admin-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-admin-annual" value="2100" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                  <div class="fixed-cost-row">
                    <div class="fixed-cost-label">Professional development</div>
                    <div class="fixed-cost-inputs">
                      <label for="fixed-cost-development-monthly">
                        <span class="input-label">Monthly</span>
                        <input type="number" id="fixed-cost-development-monthly" value="100" min="0" step="0.01" inputmode="decimal" />
                      </label>
                      <label for="fixed-cost-development-annual">
                        <span class="input-label">Annual</span>
                        <input type="number" id="fixed-cost-development-annual" value="1200" min="0" step="0.01" inputmode="decimal" />
                      </label>
                    </div>
                  </div>
                </div>
                <div class="custom-costs" id="custom-costs" aria-live="polite">
                  <div class="custom-costs__header">
                    <span class="label-text">Add your own costs</span>
                    <span
                      class="info-icon"
                      tabindex="0"
                      role="button"
                      aria-expanded="false"
                      aria-label="Track extra monthly or annual costs such as subscriptions or memberships."
                      data-tooltip="Track extra monthly or annual costs such as subscriptions or memberships."
                    >ℹ️</span>
                  </div>
                  <div class="custom-costs__form">
                    <label for="custom-cost-name" class="visually-hidden">Cost name</label>
                    <input type="text" id="custom-cost-name" placeholder="Description" />
                    <label for="custom-cost-amount" class="visually-hidden">Cost amount</label>
                    <input type="number" id="custom-cost-amount" placeholder="Amount" min="0" step="0.01" inputmode="decimal" />
                    <label for="custom-cost-frequency" class="visually-hidden">Cost frequency</label>
                    <select id="custom-cost-frequency">
                      <option value="monthly" selected>Monthly</option>
                      <option value="annual">Annual</option>
                    </select>
                    <button type="button" id="add-custom-cost">Add</button>
                  </div>
                  <div class="custom-costs__list" id="custom-cost-list" role="list"></div>
                </div>
                <p class="field-note">
                  Need benchmarks? Visit the <a href="resources.html">helpful resources</a> page.
                </p>
                <div class="fixed-cost-total">
                  <label for="fixed-costs">
                    <span class="label-text">Total fixed annual costs</span>
                  </label>
                  <input type="number" id="fixed-costs" value="25140" min="0" step="0.01" inputmode="decimal" readonly />
                  <p class="field-note">Calculated automatically from the breakdown above.</p>
                </div>
              </div>
              <div
                class="control control-panel control--variable-costs"
                role="group"
                aria-labelledby="variable-costs-label"
              >
                <div class="panel-header" id="variable-costs-label">
                  <span class="label-text">Variable costs</span>
                </div>
                <div class="panel-grid">
                  <div class="control control--nested">
                    <label for="variable-cost-class">
                      <span class="label-text">Variable cost per class</span>
                      <span
                        class="info-icon"
                        tabindex="0"
                        role="button"
                        aria-expanded="false"
                        aria-label="Expenses that apply each time you run a class, such as room hire or transport."
                        data-tooltip="Expenses that apply each time you run a class, such as room hire or transport."
                      >ℹ️</span>
                    </label>
                    <input type="number" id="variable-cost-class" value="0" min="0" step="0.01" inputmode="decimal" />
                  </div>
                  <div class="control control--nested">
                    <label for="variable-cost-student">
                      <span class="label-text">Variable cost per student</span>
                      <span
                        class="info-icon"
                        tabindex="0"
                        role="button"
                        aria-expanded="false"
                        aria-label="Per-student expenses like materials or refreshments."
                        data-tooltip="Per-student expenses like materials or refreshments."
                      >ℹ️</span>
                    </label>
                    <input type="number" id="variable-cost-student" value="0" min="0" step="0.01" inputmode="decimal" />
                  </div>
                  <div class="control control--nested">
                    <label for="variable-cost-student-monthly">
                      <span class="label-text">Variable monthly cost per student</span>
                      <span
                        class="info-icon"
                        tabindex="0"
                        role="button"
                        aria-expanded="false"
                        aria-label="Monthly expenses applied per student and scaled by class size (e.g. software licences)."
                        data-tooltip="Monthly expenses applied per student and scaled by class size (e.g. software licences)."
                      >ℹ️</span>
                    </label>
                    <input type="number" id="variable-cost-student-monthly" value="0" min="0" step="0.01" inputmode="decimal" />
                  </div>
                </div>
              </div>
              <div class="section-footer">
                <button
                  type="button"
                  class="section-toggle section-toggle--bottom"
                  data-expanded-text="Collapse section"
                  data-collapsed-text="Expand section"
                  aria-expanded="true"
                  aria-controls="section-taxes-costs"
                >
                  <span class="toggle-label">Collapse section</span>
                </button>
              </div>
            </div>
          </fieldset>

          <fieldset class="control-section" data-collapsible>
            <legend class="section-legend visually-hidden" id="section-schedule-capacity-legend">Schedule and capacity</legend>
            <div class="section-header">
              <span class="section-title" aria-hidden="true">Schedule and capacity</span>
              <button
                type="button"
                class="section-toggle section-toggle--top"
                data-expanded-text="Collapse"
                data-collapsed-text="Expand"
                aria-expanded="true"
                aria-controls="section-schedule-capacity"
              >
                <span class="toggle-label">Collapse</span>
              </button>
            </div>
            <div class="section-body" id="section-schedule-capacity">
              <div class="control">
                <label for="classes-per-week">
                  <span class="label-text">Classes per week</span>
                  <span class="info-icon" tabindex="0" role="button" aria-expanded="false" aria-label="Comma-separated integers or ranges (e.g. 4,5 or 3-8)." data-tooltip="Comma-separated integers or ranges (e.g. 4,5 or 3-8).">ℹ️</span>
                </label>
                <input type="text" id="classes-per-week" value="4,5" autocomplete="off" />
              </div>
              <div class="control">
                <label for="students-per-class">
                  <span class="label-text">Students per class</span>
                  <span class="info-icon" tabindex="0" role="button" aria-expanded="false" aria-label="Comma-separated integers or ranges (e.g. 5-12)." data-tooltip="Comma-separated integers or ranges (e.g. 5-12).">ℹ️</span>
                </label>
                <input type="text" id="students-per-class" value="4,6,8" autocomplete="off" />
              </div>
              <div class="control">
                <label for="hours-per-lesson">
                  <span class="label-text">Hours per lesson</span>
                  <span
                    class="info-icon"
                    tabindex="0"
                    role="button"
                    aria-expanded="false"
                    aria-label="Length of each lesson in hours (e.g. 1.5)."
                    data-tooltip="Length of each lesson in hours (e.g. 1.5)."
                  >ℹ️</span>
                </label>
                <input type="number" id="hours-per-lesson" value="1" min="0.25" step="0.25" inputmode="decimal" />
              </div>
              <div class="section-footer">
                <button
                  type="button"
                  class="section-toggle section-toggle--bottom"
                  data-expanded-text="Collapse section"
                  data-collapsed-text="Expand section"
                  aria-expanded="true"
                  aria-controls="section-schedule-capacity"
                >
                  <span class="toggle-label">Collapse section</span>
                </button>
              </div>
            </div>
          </fieldset>

          <fieldset class="control-section" data-collapsible>
            <legend class="section-legend visually-hidden" id="section-manual-override-legend">
              Lesson price preferences
            </legend>
            <div class="section-header">
              <span class="section-title" aria-hidden="true">Lesson price preferences</span>
              <button
                type="button"
                class="section-toggle section-toggle--top"
                data-expanded-text="Collapse"
                data-collapsed-text="Expand"
                aria-expanded="true"
                aria-controls="section-manual-override"
              >
                <span class="toggle-label">Collapse</span>
              </button>
            </div>
            <div class="section-body" id="section-manual-override">
              <div class="control">
                <label for="lesson-cost">
                  <span class="label-text">Set a specific lesson price (incl. VAT)</span>
                  <span
                    class="info-icon"
                    tabindex="0"
                    role="button" aria-expanded="false"
                    aria-label="Set a fixed per-student lesson price including VAT."
                    data-tooltip="Set a fixed per-student lesson price including VAT."
                  >ℹ️</span>
                </label>
                <input type="number" id="lesson-cost" min="0" step="0.01" inputmode="decimal" />
                <p class="field-note">Entering a lesson price updates the net income values above.</p>
              </div>
              <div
                class="control control-panel control--lesson-price-range"
                role="group"
                aria-labelledby="lesson-price-range-label"
              >
                <div class="panel-header" id="lesson-price-range-label">
                  <span class="label-text">Preferred price range (incl. VAT)</span>
                </div>
                <div class="inline-field-pair">
                  <label for="lesson-price-min">
                    <span class="input-label">Minimum</span>
                    <input type="number" id="lesson-price-min" min="0" step="0.01" inputmode="decimal" />
                  </label>
                  <label for="lesson-price-max">
                    <span class="input-label">Maximum</span>
                    <input type="number" id="lesson-price-max" min="0" step="0.01" inputmode="decimal" />
                  </label>
                </div>
                <p class="field-note">
                  Prices outside this range are highlighted in the pricing table. Leave blank to skip highlighting.
                </p>
              </div>
              <div class="section-footer">
                <button
                  type="button"
                  class="section-toggle section-toggle--bottom"
                  data-expanded-text="Collapse section"
                  data-collapsed-text="Expand section"
                  aria-expanded="true"
                  aria-controls="section-manual-override"
                >
                  <span class="toggle-label">Collapse section</span>
                </button>
              </div>
            </div>
          </fieldset>

          <fieldset class="control-section" data-collapsible>
            <legend class="section-legend visually-hidden" id="section-time-off-legend">Time planning</legend>
            <div class="section-header">
              <span class="section-title" aria-hidden="true">Time planning</span>
              <button
                type="button"
                class="section-toggle section-toggle--top"
                data-expanded-text="Collapse"
                data-collapsed-text="Expand"
                aria-expanded="true"
                aria-controls="section-time-off"
              >
                <span class="toggle-label">Collapse</span>
              </button>
            </div>
            <div class="section-body" id="section-time-off">
              <div class="control">
                <label for="active-months">
                  <span class="label-text">Active months per year</span>
                  <span
                    class="info-icon"
                    tabindex="0"
                    role="button"
                    aria-expanded="false"
                    aria-label="Enter the number of months you expect to be actively working."
                    data-tooltip="Enter the number of months you expect to be actively working. Use commas for specific values or a dash for ranges (e.g. 8,10,11 or 6-10)."
                  >ℹ️</span>
                </label>
                <input type="text" id="active-months" value="10" inputmode="decimal" />
                <p class="field-note">Separate multiple options with commas or use a range with a dash.</p>
              </div>
              <div class="control">
                <label for="weeks-off-per-month">
                  <span class="label-text">Weeks off per active month</span>
                  <span
                    class="info-icon"
                    tabindex="0"
                    role="button"
                    aria-expanded="false"
                    aria-label="Specify how many weeks you typically take off within an active month."
                    data-tooltip="Specify how many weeks you typically take off within an active month. Use commas or ranges like 0-1."
                  >ℹ️</span>
                </label>
                <input type="text" id="weeks-off-per-month" value="1" inputmode="decimal" />
                <p class="field-note">Use commas or a dash to explore different options.</p>
              </div>
              <div class="control">
                <label for="days-off-per-week">
                  <span class="label-text">Days off per 7-day week</span>
                  <span
                    class="info-icon"
                    tabindex="0"
                    role="button"
                    aria-expanded="false"
                    aria-label="Defaults to a typical weekend off in a 7-day week but supports partial-day values."
                    data-tooltip="Defaults to a typical weekend off in a 7-day week but supports partial-day values. Use commas or ranges for alternatives."
                  >ℹ️</span>
                </label>
                <input type="text" id="days-off-per-week" value="2" inputmode="decimal" />
                <p class="field-note">Separate multiple day-off scenarios with commas or ranges.</p>
              </div>
              <div class="control">
                <label>
                  <span class="label-text">Estimated working weeks per year</span>
                  <span class="info-icon" tabindex="0" role="button" aria-expanded="false" aria-label="Calculated from the schedule above." data-tooltip="Calculated from the schedule above.">ℹ️</span>
                </label>
                <output id="working-weeks-display" class="output-field">32.5</output>
              </div>
              <div class="control">
                <label>
                  <span class="label-text">Estimated working days per year</span>
                  <span class="info-icon" tabindex="0" role="button" aria-expanded="false" aria-label="Working weeks × working days per active week." data-tooltip="Working weeks × working days per active week.">ℹ️</span>
                </label>
                <output id="working-days-display" class="output-field">130</output>
              </div>
              <div class="section-footer">
                <button
                  type="button"
                  class="section-toggle section-toggle--bottom"
                  data-expanded-text="Collapse section"
                  data-collapsed-text="Expand section"
                  aria-expanded="true"
                  aria-controls="section-time-off"
                >
                  <span class="toggle-label">Collapse section</span>
                </button>
              </div>
            </div>
          </fieldset>

        </fieldset>
        <div class="button-row actions" role="group" aria-label="Actions">
          <button type="button" id="recalculate">Recalculate</button>
          <button type="button" id="download-csv" class="secondary">Download CSV</button>
          <button type="button" id="open-accounting-example" class="secondary">
            Example month accounting breakdown
          </button>
        </div>
        <p class="status-message" id="status-message" aria-live="polite"></p>
      </section>

      <section class="tables" aria-live="polite">
        <div class="variable-controls" id="variable-controls" hidden aria-live="polite"></div>
        <div class="table-grid" id="tables-container">
          <!-- Tables injected here -->
        </div>
        <div class="tables-footer">
          <h2 style="font-size: 1.05rem; margin: 0;">Assumptions</h2>
          <ul class="assumptions" id="assumptions-list"></ul>
        </div>
      </section>
    </div>

    <section class="card privacy-info" id="privacy-info" aria-labelledby="privacy-heading">
      <div>
        <h2 id="privacy-heading">Your Info Is Safe</h2>
        <p>
          This calculator runs entirely in your browser. There are no sign-ins, accounts, or background network calls. Everything
          you type stays on this page. By default the only thing saved between visits is your light/dark mode preference
          (<code>income-calculator-theme</code>). If you turn on “Remember my inputs,” the calculator also stores your latest form values
          (<code>income-calculator-saved-inputs</code>) plus a small flag (<code>income-calculator-save-enabled</code>) in local storage. Switch it
          off or press “Reset to defaults” to remove them instantly.
        </p>
        <p>
          When you export results, the CSV file is generated on your device: the app assembles the rows, wraps them in a
          <code>Blob</code>, spawns a temporary download link, clicks it for you, and immediately cleans it up again, so nothing
          leaves your device. Want to dig deeper? The full source code is available on
          <a href="https://github.com/jd-d/income-calc" target="_blank" rel="noreferrer noopener">GitHub</a>, review it yourself or with a
          developer you trust to confirm exactly how the site works.
        </p>
      </div>
      <div>
        <h3>Easy ways to verify this yourself</h3>
        <ol>
          <li>
            <strong>Check that no cookies are created.</strong> Open DevTools → Application/Storage → Cookies, reload the page,
            and interact with the calculator. The cookies list will stay empty.
          </li>
          <li>
            <strong>Inspect local storage.</strong> In the same panel, open “Local Storage,” select the site origin, and confirm
            you see <code>income-calculator-theme</code>, plus <code>income-calculator-saved-inputs</code> and
            <code>income-calculator-save-enabled</code> only if you enabled “Remember my inputs.” Toggle it off or use “Reset to
            defaults” to clear the extra entries.
          </li>
          <li>
            <strong>Watch for network requests.</strong> Keep the Network tab open with “Preserve log” enabled as you adjust
            inputs and export CSV. You’ll see no additional requests after the initial page load because every
            calculation happens locally.
          </li>
          <li>
            <strong>Review the page source.</strong> Search for calls like <code>fetch</code>, <code>XMLHttpRequest</code>, or
            <code>navigator.sendBeacon</code>. You’ll only find <code>localStorage.getItem</code>/<code>setItem</code> for the theme
            preference and the optional saved inputs toggle.
          </li>
          <li>
            <strong>Browse the GitHub repository.</strong> Inspect the project files directly on <a href="https://github.com/jd-d/income-calc" target="_blank" rel="noreferrer noopener">GitHub</a> to confirm exactly what
            the site ships and how it behaves.
          </li>
        </ol>
      </div>
    </section>
  </div>

  <div
    class="lesson-breakdown-dialog"
    id="lesson-breakdown-dialog"
    role="dialog"
    aria-modal="true"
    aria-labelledby="lesson-breakdown-title"
    aria-describedby="lesson-breakdown-summary"
    hidden
  >
    <div class="lesson-breakdown-dialog__backdrop" id="lesson-breakdown-backdrop" tabindex="-1"></div>
    <div class="lesson-breakdown-dialog__content" role="document">
      <div class="lesson-breakdown-dialog__header">
        <div>
          <h2 id="lesson-breakdown-title">Lesson breakdown</h2>
          <p class="lesson-breakdown-dialog__variant" id="lesson-breakdown-variant"></p>
        </div>
        <button
          type="button"
          class="lesson-breakdown-dialog__close"
          id="lesson-breakdown-close"
          aria-label="Close lesson breakdown"
        >×</button>
      </div>
      <div class="lesson-breakdown-dialog__summary" id="lesson-breakdown-summary">
        <p class="lesson-breakdown-dialog__price" id="lesson-breakdown-price"></p>
        <p class="lesson-breakdown-dialog__meta" id="lesson-breakdown-meta"></p>
        <p class="lesson-breakdown-dialog__total" id="lesson-breakdown-total"></p>
      </div>
      <div class="lesson-breakdown-dialog__body">
        <div class="lesson-breakdown-dialog__table-wrapper">
          <table class="lesson-breakdown-table">
            <caption class="visually-hidden">Per-student and per-lesson financial breakdown</caption>
            <thead>
              <tr>
                <th scope="col">Line item</th>
                <th scope="col">Per student</th>
                <th scope="col">Per lesson</th>
              </tr>
            </thead>
            <tbody id="lesson-breakdown-table-body"></tbody>
          </table>
        </div>
        <div class="lesson-breakdown-dialog__chart">
          <div class="lesson-breakdown-dialog__chart-graphic" id="lesson-breakdown-chart-graphic" aria-hidden="true"></div>
          <ul class="lesson-breakdown-dialog__legend" id="lesson-breakdown-legend"></ul>
        </div>
      </div>
    </div>
  </div>

  <div class="readme-dialog" id="readme-dialog" role="dialog" aria-modal="true" aria-labelledby="readme-title" hidden>
    <div class="readme-dialog__backdrop" id="readme-backdrop" tabindex="-1"></div>
    <div class="readme-dialog__content" role="document">
      <div class="readme-dialog__header">
        <h2 id="readme-title">How To Use This Tool</h2>
        <button type="button" class="readme-dialog__close" id="readme-close" aria-label="Close instructions">×</button>
      </div>
      <div class="readme-dialog__body" id="readme-body" tabindex="0"></div>
    </div>
  </div>

  <div
    class="accounting-dialog"
    id="accounting-dialog"
    role="dialog"
    aria-modal="true"
    aria-labelledby="accounting-title"
    aria-describedby="accounting-subtitle"
    hidden
  >
    <div class="accounting-dialog__backdrop" id="accounting-backdrop" tabindex="-1"></div>
    <div class="accounting-dialog__content" role="document">
      <div class="accounting-dialog__header">
        <div>
          <h2 class="accounting-dialog__title" id="accounting-title">Example month accounting breakdown</h2>
          <p class="accounting-dialog__subtitle" id="accounting-subtitle">
            Enter the class mix you want to showcase and we’ll assemble an accountant-style monthly report.
          </p>
        </div>
        <button
          type="button"
          class="accounting-dialog__close"
          id="accounting-close"
          aria-label="Close accounting breakdown form"
        >×</button>
      </div>
      <form class="accounting-dialog__form" id="accounting-form">
        <div class="accounting-dialog__field">
          <label for="accounting-students">Students per class</label>
          <input
            type="number"
            id="accounting-students"
            name="accounting-students"
            min="1"
            step="1"
            inputmode="numeric"
            required
          />
        </div>
        <div class="accounting-dialog__field">
          <label for="accounting-classes">Classes per week</label>
          <input
            type="number"
            id="accounting-classes"
            name="accounting-classes"
            min="0.25"
            step="0.25"
            inputmode="decimal"
            required
          />
        </div>
        <div class="accounting-dialog__field">
          <label for="accounting-hours">Hours per class</label>
          <input
            type="number"
            id="accounting-hours"
            name="accounting-hours"
            min="0.25"
            step="0.25"
            inputmode="decimal"
            required
          />
        </div>
        <p class="accounting-dialog__note">
          The values default to your current calculator inputs. Adjust them if you want to illustrate a different class mix.
        </p>
        <p class="accounting-dialog__error" id="accounting-error" role="alert" aria-live="polite"></p>
        <div class="accounting-dialog__actions">
          <button type="button" class="secondary" id="accounting-cancel">Cancel</button>
          <button type="submit" id="accounting-generate">Generate</button>
        </div>
      </form>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    const breakdownDialog = document.getElementById('lesson-breakdown-dialog');
    const breakdownBackdrop = document.getElementById('lesson-breakdown-backdrop');
    const breakdownClose = document.getElementById('lesson-breakdown-close');
    const breakdownSummary = document.getElementById('lesson-breakdown-summary');
    const breakdownVariant = document.getElementById('lesson-breakdown-variant');
    const breakdownPrice = document.getElementById('lesson-breakdown-price');
    const breakdownMeta = document.getElementById('lesson-breakdown-meta');
    const breakdownTotal = document.getElementById('lesson-breakdown-total');
    const breakdownTableBody = document.getElementById('lesson-breakdown-table-body');
    const breakdownChartGraphic = document.getElementById('lesson-breakdown-chart-graphic');
    const breakdownLegend = document.getElementById('lesson-breakdown-legend');
    const howToLink = document.getElementById('how-to-link');
    const readmeDialog = document.getElementById('readme-dialog');
    const readmeBody = document.getElementById('readme-body');
    const readmeClose = document.getElementById('readme-close');
    const readmeBackdrop = document.getElementById('readme-backdrop');
    const accountingDialog = document.getElementById('accounting-dialog');
    const accountingBackdrop = document.getElementById('accounting-backdrop');
    const accountingClose = document.getElementById('accounting-close');
    const accountingForm = document.getElementById('accounting-form');
    const accountingStudentsInput = document.getElementById('accounting-students');
    const accountingClassesInput = document.getElementById('accounting-classes');
    const accountingHoursInput = document.getElementById('accounting-hours');
    const accountingError = document.getElementById('accounting-error');
    const accountingCancel = document.getElementById('accounting-cancel');
    let readmeLoaded = false;
    let readmeLoading = false;
    let previouslyFocusedElement = null;
    let breakdownTriggerElement = null;
    let activeBreakdownContext = null;
    let accountingTriggerElement = null;

    const controls = {
      targetNet: document.getElementById('target-net'),
      targetNetWeek: document.getElementById('target-net-week'),
      targetNetMonth: document.getElementById('target-net-month'),
      targetNetAverageWeek: document.getElementById('target-net-average-week'),
      targetNetAverageMonth: document.getElementById('target-net-average-month'),
      desiredIncomeToggleDisplay: document.getElementById('desired-income-toggle-display'),
      desiredIncomeToggleInterpretation: document.getElementById('desired-income-toggle-interpretation'),
      acceptableIncomeMin: document.getElementById('acceptable-income-min'),
      acceptableIncomeMax: document.getElementById('acceptable-income-max'),
      acceptableIncomeBasisMonthly: document.getElementById('acceptable-income-basis-monthly'),
      acceptableIncomeBasisAnnual: document.getElementById('acceptable-income-basis-annual'),
      taxRate: document.getElementById('tax-rate'),
      fixedCosts: document.getElementById('fixed-costs'),
      variableCostPerClass: document.getElementById('variable-cost-class'),
      variableCostPerStudent: document.getElementById('variable-cost-student'),
      variableCostPerStudentMonthly: document.getElementById('variable-cost-student-monthly'),
      vatRate: document.getElementById('vat-rate'),
      classesPerWeek: document.getElementById('classes-per-week'),
      studentsPerClass: document.getElementById('students-per-class'),
      hoursPerLesson: document.getElementById('hours-per-lesson'),
      lessonCost: document.getElementById('lesson-cost'),
      lessonPriceMin: document.getElementById('lesson-price-min'),
      lessonPriceMax: document.getElementById('lesson-price-max'),
      activeMonthsInput: document.getElementById('active-months'),
      weeksOffPerMonthInput: document.getElementById('weeks-off-per-month'),
      daysOffPerWeekInput: document.getElementById('days-off-per-week'),
      buffer: document.getElementById('buffer'),
      currencySymbol: document.getElementById('currency-symbol'),
      recalcButton: document.getElementById('recalculate'),
      downloadCsv: document.getElementById('download-csv'),
      accountingExample: document.getElementById('open-accounting-example'),
      statusMessage: document.getElementById('status-message'),
      workingWeeksDisplay: document.getElementById('working-weeks-display'),
      workingDaysDisplay: document.getElementById('working-days-display'),
      customCostName: document.getElementById('custom-cost-name'),
      customCostAmount: document.getElementById('custom-cost-amount'),
      customCostFrequency: document.getElementById('custom-cost-frequency'),
      addCustomCostButton: document.getElementById('add-custom-cost'),
      customCostList: document.getElementById('custom-cost-list'),
      rememberInputs: document.getElementById('remember-inputs'),
      resetSavedInputs: document.getElementById('reset-saved-inputs')
    };

    const desiredIncomeFieldMap = {
      year: controls.targetNet,
      week: controls.targetNetWeek,
      month: controls.targetNetMonth,
      avgWeek: controls.targetNetAverageWeek,
      avgMonth: controls.targetNetAverageMonth
    };

    const COLLAPSIBLE_SECTION_SELECTOR = '.control-section[data-collapsible]';

    function getSectionLabel(section, index = 0) {
      if (!section) {
        return `Section ${index + 1}`;
      }

      const title = section.querySelector('.section-title');
      const labelText = title && title.textContent ? title.textContent.trim() : '';

      if (labelText) {
        section.dataset.sectionLabel = labelText;
        return labelText;
      }

      if (section.dataset.sectionLabel) {
        return section.dataset.sectionLabel;
      }

      const fallback = `Section ${index + 1}`;
      section.dataset.sectionLabel = fallback;
      return fallback;
    }

    function updateToggleButtonState(toggle, collapsed, sectionLabel) {
      if (!toggle) {
        return;
      }

      const expandedText = toggle.getAttribute('data-expanded-text') || 'Collapse section';
      const collapsedText = toggle.getAttribute('data-collapsed-text') || 'Expand section';
      const labelElement = toggle.querySelector('.toggle-label');
      const nextText = collapsed ? collapsedText : expandedText;

      if (labelElement) {
        labelElement.textContent = nextText;
      } else {
        toggle.textContent = nextText;
      }

      const actionText = collapsed ? collapsedText : expandedText;
      const normalizedAction = actionText.replace(/\s+section$/i, '');
      const normalizedLabel = sectionLabel || 'section';

      toggle.setAttribute('aria-expanded', String(!collapsed));
      toggle.setAttribute('aria-label', `${normalizedAction} ${normalizedLabel} section`);
      toggle.setAttribute('title', `${normalizedAction} ${normalizedLabel} section`);
    }

    const collapsibleSections = new Map();

    function registerCollapsibleSection(section) {
      if (!(section instanceof HTMLElement)) {
        return;
      }

      const body = section.querySelector('.section-body');
      if (!(body instanceof HTMLElement)) {
        return;
      }

      const existing = collapsibleSections.get(section);
      const listeners = existing ? existing.listeners : new Map();
      const collapsed = section.classList.contains('collapsed');
      const fallbackIndex = collapsibleSections.size;
      const sectionLabel = getSectionLabel(section, fallbackIndex);
      section.dataset.sectionLabel = sectionLabel;

      if (!body.id) {
        const baseId = sectionLabel
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/(^-|-$)/g, '') || `section-${fallbackIndex + 1}`;

        let uniqueId = baseId;
        let attempt = 1;
        while (document.getElementById(uniqueId)) {
          attempt += 1;
          uniqueId = `${baseId}-${attempt}`;
        }

        body.id = uniqueId;
      }

      const seenToggles = new Set();
      section.querySelectorAll('.section-toggle').forEach(toggle => {
        if (!(toggle instanceof HTMLElement)) {
          return;
        }

        seenToggles.add(toggle);

        if (!listeners.has(toggle)) {
          const handler = event => {
            event.preventDefault();
            toggleCollapsibleSection(section, { trigger: toggle });
          };
          toggle.addEventListener('click', handler);
          listeners.set(toggle, handler);
        }

        toggle.setAttribute('aria-controls', body.id);
        updateToggleButtonState(toggle, collapsed, sectionLabel);
      });

      if (existing) {
        for (const [toggle, handler] of listeners) {
          if (!seenToggles.has(toggle)) {
            toggle.removeEventListener('click', handler);
            listeners.delete(toggle);
          }
        }
      }

      collapsibleSections.set(section, { body, listeners });
    }

    function unregisterCollapsibleSection(section) {
      const data = collapsibleSections.get(section);
      if (!data) {
        return;
      }

      for (const [toggle, handler] of data.listeners) {
        toggle.removeEventListener('click', handler);
      }

      collapsibleSections.delete(section);
    }

    function captureCollapsibleSectionStates() {
      const states = {};
      document.querySelectorAll(COLLAPSIBLE_SECTION_SELECTOR).forEach(section => {
        if (!(section instanceof HTMLElement)) {
          return;
        }
        const body = section.querySelector('.section-body');
        const key = body instanceof HTMLElement ? body.id : '';
        if (!key) {
          return;
        }
        states[key] = section.classList.contains('collapsed');
      });
      return states;
    }

    function applyCollapsibleSectionStates(states, { skipPersistence = false } = {}) {
      if (!states || typeof states !== 'object') {
        return;
      }
      document.querySelectorAll(COLLAPSIBLE_SECTION_SELECTOR).forEach(section => {
        if (!(section instanceof HTMLElement)) {
          return;
        }
        const body = section.querySelector('.section-body');
        const key = body instanceof HTMLElement ? body.id : '';
        if (!key || !Object.prototype.hasOwnProperty.call(states, key)) {
          return;
        }
        toggleCollapsibleSection(section, {
          explicitState: Boolean(states[key]),
          skipPersistence: skipPersistence === true
        });
      });
    }

    function toggleCollapsibleSection(section, { trigger, explicitState, skipPersistence = false } = {}) {
      if (!(section instanceof HTMLElement)) {
        return;
      }

      if (!collapsibleSections.has(section)) {
        registerCollapsibleSection(section);
      }

      const data = collapsibleSections.get(section);
      if (!data) {
        return;
      }

      const isCollapsed = section.classList.contains('collapsed');
      const nextCollapsed = typeof explicitState === 'boolean' ? explicitState : !isCollapsed;

      if (nextCollapsed === isCollapsed) {
        const scroll = () => {
          if (typeof section.scrollIntoView === 'function') {
            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        };

        if (typeof requestAnimationFrame === 'function') {
          requestAnimationFrame(scroll);
        } else {
          scroll();
        }
        return;
      }

      section.classList.toggle('collapsed', nextCollapsed);
      const sectionLabel = getSectionLabel(section, 0);
      section.dataset.sectionLabel = sectionLabel;

      for (const toggle of data.listeners.keys()) {
        updateToggleButtonState(toggle, nextCollapsed, sectionLabel);
      }

      if (nextCollapsed && trigger && trigger.classList.contains('section-toggle--bottom')) {
        const topToggle = section.querySelector('.section-toggle--top');
        if (topToggle && typeof topToggle.focus === 'function') {
          try {
            topToggle.focus({ preventScroll: true });
          } catch (error) {
            topToggle.focus();
          }
        }
      }

      const scroll = () => {
        if (typeof section.scrollIntoView === 'function') {
          section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      if (typeof requestAnimationFrame === 'function') {
        requestAnimationFrame(scroll);
      } else {
        scroll();
      }

      if (!skipPersistence && persistenceEnabled) {
        savePersistedInputs();
      }
    }

    function refreshCollapsibleSections(root = document) {
      Array.from(root.querySelectorAll(COLLAPSIBLE_SECTION_SELECTOR)).forEach(section => {
        registerCollapsibleSection(section);
      });
    }

    refreshCollapsibleSections(document);

    if (typeof MutationObserver === 'function') {
      const observerTarget = document.body || document.documentElement;
      if (observerTarget) {
        const collapsibleObserver = new MutationObserver(mutations => {
          for (const mutation of mutations) {
            mutation.addedNodes?.forEach(node => {
              if (!(node instanceof HTMLElement)) {
                return;
              }

              if (node.matches && node.matches(COLLAPSIBLE_SECTION_SELECTOR)) {
                registerCollapsibleSection(node);
              }

              if (typeof node.querySelectorAll === 'function') {
                node.querySelectorAll(COLLAPSIBLE_SECTION_SELECTOR).forEach(childSection => {
                  registerCollapsibleSection(childSection);
                });
              }
            });

            mutation.removedNodes?.forEach(node => {
              if (!(node instanceof HTMLElement)) {
                return;
              }

              if (collapsibleSections.has(node)) {
                unregisterCollapsibleSection(node);
              }

              if (typeof node.querySelectorAll === 'function') {
                node.querySelectorAll(COLLAPSIBLE_SECTION_SELECTOR).forEach(childSection => {
                  unregisterCollapsibleSection(childSection);
                });
              }
            });
          }
        });

        collapsibleObserver.observe(observerTarget, { childList: true, subtree: true });
      }
    }

    function getFocusableElements(container) {
      if (!container) {
        return [];
      }

      const selectors = [
        'a[href]',
        'button:not([disabled])',
        'textarea:not([disabled])',
        'input:not([disabled])',
        'select:not([disabled])',
        '[tabindex]:not([tabindex="-1"])'
      ].join(',');

      return Array.from(container.querySelectorAll(selectors)).filter(element => {
        if (element.hasAttribute('hidden') || element.getAttribute('aria-hidden') === 'true') {
          return false;
        }
        const rect = element.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
      });
    }

    const activeDialogLocks = new Set();

    function setBodyScrollLock(source, locked) {
      if (!source) {
        return;
      }

      if (locked) {
        activeDialogLocks.add(source);
      } else {
        activeDialogLocks.delete(source);
      }

      if (activeDialogLocks.size > 0) {
        document.body.classList.add('dialog-open');
      } else {
        document.body.classList.remove('dialog-open');
      }
    }

    function parseMarkdown(text) {
      if (window.marked && typeof window.marked.parse === 'function') {
        return window.marked.parse(text);
      }
      const escaped = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      return `<pre>${escaped}</pre>`;
    }

    const README_SOURCES = [
      new URL('README.md', document.baseURI).toString(),
      'https://raw.githubusercontent.com/jd-d/income-calc/main/README.md'
    ];

    function fetchReadmeFromSources(sources, index = 0) {
      if (!Array.isArray(sources) || index >= sources.length) {
        return Promise.reject(new Error('No README sources available'));
      }

      const source = sources[index];

      return fetch(source)
        .then(response => {
          if (!response || !response.ok) {
            throw new Error(`Failed to load README from ${source} (status ${response ? response.status : 'unknown'})`);
          }
          return response.text();
        })
        .catch(error => {
          if (index < sources.length - 1) {
            if (console && typeof console.warn === 'function') {
              console.warn(error);
            }

            if (readmeBody) {
              readmeBody.innerHTML = '<p class="readme-status">Retrying with a backup instructions source…</p>';
            }

            return fetchReadmeFromSources(sources, index + 1);
          }

          throw error;
        });
    }

    function loadReadme() {
      if (readmeLoaded || readmeLoading || !readmeBody) {
        return;
      }

      readmeLoading = true;

      fetchReadmeFromSources(README_SOURCES)
        .then(text => {
          readmeBody.innerHTML = parseMarkdown(text);
          readmeLoaded = true;
        })
        .catch(() => {
          readmeBody.innerHTML = '<p class="readme-status readme-status--error">Unable to load instructions. Please check the README file directly.</p>';
        })
        .finally(() => {
          readmeLoading = false;
        });
    }

    function openReadme(event) {
      if (event) {
        event.preventDefault();
      }

      if (!readmeDialog || !readmeBody) {
        return;
      }

      previouslyFocusedElement = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      readmeDialog.hidden = false;
      setBodyScrollLock('readme', true);

      if (!readmeLoaded) {
        readmeBody.innerHTML = '<p class="readme-status">Loading instructions…</p>';
        loadReadme();
      }

      window.requestAnimationFrame(() => {
        if (readmeClose) {
          readmeClose.focus();
        }
      });

      document.addEventListener('keydown', handleReadmeKeydown);
    }

    function closeReadme() {
      if (!readmeDialog) {
        return;
      }

      readmeDialog.hidden = true;
      setBodyScrollLock('readme', false);
      document.removeEventListener('keydown', handleReadmeKeydown);

      if (previouslyFocusedElement && typeof previouslyFocusedElement.focus === 'function') {
        previouslyFocusedElement.focus();
      }
    }

    function handleReadmeKeydown(event) {
      if (event.key === 'Escape') {
        closeReadme();
        return;
      }

      if (event.key === 'Tab' && readmeDialog && !readmeDialog.hidden) {
        const focusable = getFocusableElements(readmeDialog);
        if (focusable.length === 0) {
          event.preventDefault();
          return;
        }

        const first = focusable[0];
        const last = focusable[focusable.length - 1];

        if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        } else if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        }
      }
    }

    function openAccountingDialog(event) {
      if (event) {
        event.preventDefault();
      }

      if (!accountingDialog) {
        return;
      }

      if (!latestInputsSnapshot) {
        const snapshotInputs = getInputs();
        latestInputsSnapshot = cloneInputs(snapshotInputs);
      }

      accountingTriggerElement = document.activeElement instanceof HTMLElement ? document.activeElement : null;

      const snapshot = latestInputsSnapshot || {};
      const setFieldValue = (input, value, digits = 2) => {
        if (!(input instanceof HTMLInputElement)) {
          return;
        }
        if (Number.isFinite(value)) {
          input.value = formatFixed(value, digits);
        } else if (typeof input.value !== 'string' || input.value.trim() === '') {
          input.value = '';
        }
      };

      const defaultStudents = Array.isArray(snapshot.studentsPerClass) && snapshot.studentsPerClass.length
        ? snapshot.studentsPerClass[0]
        : null;
      const defaultClasses = Array.isArray(snapshot.classesPerWeek) && snapshot.classesPerWeek.length
        ? snapshot.classesPerWeek[0]
        : null;
      const defaultHours = Number.isFinite(snapshot.hoursPerLesson) ? snapshot.hoursPerLesson : null;

      setFieldValue(accountingStudentsInput, defaultStudents, 0);
      setFieldValue(accountingClassesInput, defaultClasses, 2);
      setFieldValue(accountingHoursInput, defaultHours, 2);

      if (accountingError) {
        accountingError.textContent = '';
      }

      accountingDialog.hidden = false;
      setBodyScrollLock('accounting', true);

      window.requestAnimationFrame(() => {
        if (accountingStudentsInput instanceof HTMLInputElement) {
          accountingStudentsInput.focus();
          accountingStudentsInput.select();
        }
      });

      document.addEventListener('keydown', handleAccountingKeydown);
    }

    function closeAccountingDialog() {
      if (!accountingDialog) {
        return;
      }

      accountingDialog.hidden = true;
      setBodyScrollLock('accounting', false);
      document.removeEventListener('keydown', handleAccountingKeydown);

      if (accountingError) {
        accountingError.textContent = '';
      }

      const trigger = accountingTriggerElement;
      accountingTriggerElement = null;
      if (trigger && typeof trigger.focus === 'function') {
        trigger.focus();
      }
    }

    function handleAccountingKeydown(event) {
      if (event.key === 'Escape') {
        closeAccountingDialog();
        return;
      }

      if (event.key === 'Tab' && accountingDialog && !accountingDialog.hidden) {
        const focusable = getFocusableElements(accountingDialog);
        if (focusable.length === 0) {
          event.preventDefault();
          return;
        }

        const first = focusable[0];
        const last = focusable[focusable.length - 1];

        if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        } else if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        }
      }
    }

    function handleAccountingSubmit(event) {
      event.preventDefault();

      const studentsValue = Number(accountingStudentsInput?.value);
      if (!Number.isFinite(studentsValue) || studentsValue <= 0) {
        if (accountingError) {
          accountingError.textContent = 'Enter a positive number of students per class.';
        }
        if (accountingStudentsInput instanceof HTMLInputElement) {
          accountingStudentsInput.focus();
          accountingStudentsInput.select();
        }
        return;
      }

      const classesPerWeekValue = Number(accountingClassesInput?.value);
      if (!Number.isFinite(classesPerWeekValue) || classesPerWeekValue <= 0) {
        if (accountingError) {
          accountingError.textContent = 'Enter how many classes you plan to run each week (must be greater than 0).';
        }
        if (accountingClassesInput instanceof HTMLInputElement) {
          accountingClassesInput.focus();
          accountingClassesInput.select();
        }
        return;
      }

      const hoursPerClassValue = Number(accountingHoursInput?.value);
      if (!Number.isFinite(hoursPerClassValue) || hoursPerClassValue <= 0) {
        if (accountingError) {
          accountingError.textContent = 'Enter how long each class lasts in hours (must be greater than 0).';
        }
        if (accountingHoursInput instanceof HTMLInputElement) {
          accountingHoursInput.focus();
          accountingHoursInput.select();
        }
        return;
      }

      if (!Array.isArray(latestPricingData) || !latestPricingData.length) {
        if (accountingError) {
          accountingError.textContent = 'Generate the pricing table first by adding class and student values, then press Recalculate.';
        }
        return;
      }

      if (!latestInputsSnapshot) {
        latestInputsSnapshot = cloneInputs(getInputs());
      }

      const combination = findBestPricingCombination(studentsValue, classesPerWeekValue, latestPricingData);
      if (!combination) {
        if (accountingError) {
          accountingError.textContent = 'No pricing data matches those values. Add the combination to your table and recalculate.';
        }
        return;
      }

      const reportHtml = buildAccountingReport({
        studentsRequested: studentsValue,
        classesPerWeekRequested: classesPerWeekValue,
        hoursPerClassRequested: hoursPerClassValue,
        combination,
        inputs: latestInputsSnapshot,
        currencySymbol: latestInputsSnapshot?.currencySymbol || latestCurrencySymbol,
        pricingMode: latestPricingMode,
        bufferPercent: latestBufferPercent,
        bufferedMonthlyNet: latestPricingMode === PRICING_MODE_LESSON
          ? combination.column?.manualNet?.bufferedMonthly
          : combination.column?.buffered?.monthlyNet
      });

      if (!reportHtml) {
        if (accountingError) {
          accountingError.textContent = 'Unable to assemble the report. Please recalculate the table and try again.';
        }
        return;
      }

      const blob = new Blob([reportHtml], { type: 'text/html;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      const timestamp = new Date().toISOString().slice(0, 10);
      link.download = `accounting-breakdown-${timestamp}.html`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      if (accountingError) {
        accountingError.textContent = '';
      }

      closeAccountingDialog();

      if (controls.statusMessage) {
        controls.statusMessage.textContent = 'HTML download started. File contains an accountant-style monthly breakdown.';
        window.setTimeout(() => {
          if (controls.statusMessage) {
            controls.statusMessage.textContent = '';
          }
        }, 2500);
      }
    }

    if (howToLink) {
      howToLink.addEventListener('click', openReadme);
    }

    if (readmeClose) {
      readmeClose.addEventListener('click', closeReadme);
    }

    if (readmeBackdrop) {
      readmeBackdrop.addEventListener('click', closeReadme);
    }

    if (readmeDialog) {
      readmeDialog.addEventListener('click', event => {
        if (event.target === readmeDialog) {
          closeReadme();
        }
      });
    }

    if (controls.accountingExample instanceof HTMLButtonElement) {
      controls.accountingExample.addEventListener('click', openAccountingDialog);
    }

    if (accountingClose) {
      accountingClose.addEventListener('click', closeAccountingDialog);
    }

    if (accountingCancel) {
      accountingCancel.addEventListener('click', closeAccountingDialog);
    }

    if (accountingBackdrop) {
      accountingBackdrop.addEventListener('click', closeAccountingDialog);
    }

    if (accountingDialog) {
      accountingDialog.addEventListener('click', event => {
        if (event.target === accountingDialog) {
          closeAccountingDialog();
        }
      });
    }

    if (accountingForm) {
      accountingForm.addEventListener('submit', handleAccountingSubmit);
    }

    if (controls.addCustomCostButton instanceof HTMLButtonElement) {
      controls.addCustomCostButton.addEventListener('click', handleAddCustomCost);
    }

    if (controls.customCostList instanceof HTMLElement) {
      controls.customCostList.addEventListener('click', event => {
        const target =
          event.target instanceof HTMLElement ? event.target.closest('button[data-cost-id]') : null;
        if (!target) {
          return;
        }
        const costId = target.getAttribute('data-cost-id');
        if (typeof costId === 'string' && costId) {
          removeCustomCost(costId);
        }
      });
    }

    renderCustomCostList();

    [accountingStudentsInput, accountingClassesInput, accountingHoursInput].forEach(input => {
      if (input instanceof HTMLInputElement) {
        input.addEventListener('input', () => {
          if (accountingError) {
            accountingError.textContent = '';
          }
        });
      }
    });

    if (breakdownClose) {
      breakdownClose.addEventListener('click', closeBreakdownDialog);
    }

    if (breakdownBackdrop) {
      breakdownBackdrop.addEventListener('click', closeBreakdownDialog);
    }

    if (breakdownDialog) {
      breakdownDialog.addEventListener('click', event => {
        if (event.target === breakdownDialog) {
          closeBreakdownDialog();
        }
      });
    }

    const themeToggleButton = document.getElementById('theme-toggle');
    const themeToggleLabel = themeToggleButton ? themeToggleButton.querySelector('.toggle-label') : null;
    const THEME_STORAGE_KEY = 'income-calculator-theme';
    const prefersDarkScheme = typeof window.matchMedia === 'function'
      ? window.matchMedia('(prefers-color-scheme: dark)')
      : { matches: true };

    function getStoredTheme() {
      try {
        const stored = localStorage.getItem(THEME_STORAGE_KEY);
        if (stored === 'light' || stored === 'dark') {
          return stored;
        }
      } catch (error) {
        // Ignore storage access errors (e.g. private browsing restrictions)
      }
      return null;
    }

    function applyThemePreference(theme, { save = true } = {}) {
      const normalized = theme === 'light' ? 'light' : 'dark';
      document.body.dataset.theme = normalized;

      if (save) {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, normalized);
        } catch (error) {
          // Ignore storage access errors
        }
      }

      if (themeToggleButton && themeToggleLabel) {
        const isDark = normalized === 'dark';
        const actionLabel = `Switch to ${isDark ? 'light' : 'dark'} mode`;
        themeToggleButton.setAttribute('aria-pressed', String(isDark));
        themeToggleButton.setAttribute('aria-label', actionLabel);
        themeToggleButton.setAttribute('title', actionLabel);
        themeToggleLabel.textContent = isDark ? 'Dark mode' : 'Light mode';
      }

      document.dispatchEvent(
        new CustomEvent('themechange', { detail: normalized })
      );
    }

    const storedTheme = getStoredTheme();
    let respectSystemPreference = !storedTheme;

    applyThemePreference(storedTheme || (prefersDarkScheme.matches ? 'dark' : 'light'), {
      save: Boolean(storedTheme)
    });

    function handlePreferenceChange(event) {
      if (respectSystemPreference) {
        applyThemePreference(event.matches ? 'dark' : 'light', { save: false });
      }
    }

    if (typeof prefersDarkScheme.addEventListener === 'function') {
      prefersDarkScheme.addEventListener('change', handlePreferenceChange);
    } else if (typeof prefersDarkScheme.addListener === 'function') {
      prefersDarkScheme.addListener(handlePreferenceChange);
    }

    if (themeToggleButton) {
      themeToggleButton.addEventListener('click', () => {
        const nextTheme = document.body.dataset.theme === 'dark' ? 'light' : 'dark';
        respectSystemPreference = false;
        applyThemePreference(nextTheme);
      });
    }

    const numberFormatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });

    let latestResults = [];
    let showBasePrices = false;
    let targetNetBasis = 'year';
    let desiredIncomeDisplayMode = 'net';
    let desiredIncomeLockedAsGross = false;
    let desiredIncomeLockedGrossValues = null;
    let acceptableIncomeLockedGrossMin = null;
    let acceptableIncomeLockedGrossMax = null;
    let acceptableIncomeLockedGrossMinBasis = null;
    let acceptableIncomeLockedGrossMaxBasis = null;
    let desiredIncomePreviousNetValues = null;
    const PRICING_MODE_TARGET = 'target';
    const PRICING_MODE_LESSON = 'lesson';
    let latestResultsMode = PRICING_MODE_TARGET;
    let latestPricingData = null;
    let latestCurrencySymbol = '€';
    let latestPricingMode = PRICING_MODE_TARGET;
    let latestBufferPercent = 0;
    let latestInputsSnapshot = null;
    let customCosts = [];
    let customCostIdCounter = 0;
    const PERSISTED_TARGET_NET_BASIS_KEY = '__targetNetBasis';
    const PERSISTED_DESIRED_INCOME_DISPLAY_KEY = '__desiredIncomeDisplay';
    const PERSISTED_DESIRED_INCOME_LOCK_KEY = '__desiredIncomeLock';
    const VARIABLE_META = {
      studentsPerClass: {
        key: 'studentsPerClass',
        label: 'Students per class',
        axisLabel: 'Students per class',
        fractionDigits: 0
      },
      classesPerWeek: {
        key: 'classesPerWeek',
        label: 'Classes per week',
        axisLabel: 'Classes per week',
        fractionDigits: 0
      },
      activeMonths: {
        key: 'activeMonths',
        label: 'Active months per year',
        axisLabel: 'Active months per year',
        fractionDigits: 0
      },
      weeksOffPerMonth: {
        key: 'weeksOffPerMonth',
        label: 'Weeks off per active month',
        axisLabel: 'Weeks off per active month',
        fractionDigits: 0
      },
      daysOffPerWeek: {
        key: 'daysOffPerWeek',
        label: 'Days off per 7-day week',
        axisLabel: 'Days off per 7-day week',
        fractionDigits: 0
      }
    };
    const VARIABLE_ORDER = [
      'studentsPerClass',
      'classesPerWeek',
      'activeMonths',
      'weeksOffPerMonth',
      'daysOffPerWeek'
    ];
    let variableSelection = { axes: [null, null], fixedValues: {} };
    const PERSISTED_ACCEPTABLE_INCOME_MIN_KEY = '__acceptableIncomeMinAnnualNet';
    const PERSISTED_ACCEPTABLE_INCOME_MAX_KEY = '__acceptableIncomeMaxAnnualNet';
    const PERSISTED_ACCEPTABLE_INCOME_BASIS_KEY = '__acceptableIncomeBasis';
    const PERSISTED_COLLAPSED_SECTIONS_KEY = '__collapsedSectionsState';
    const TARGET_NET_BASIS_VALUES = ['year', 'week', 'month', 'avgWeek', 'avgMonth'];
    const TARGET_NET_BASIS_BY_INPUT_ID = {
      'target-net': 'year',
      'target-net-week': 'week',
      'target-net-month': 'month',
      'target-net-average-week': 'avgWeek',
      'target-net-average-month': 'avgMonth'
    };

    function getDesiredIncomeField(key) {
      const field = desiredIncomeFieldMap[key];
      return field instanceof HTMLInputElement ? field : null;
    }

    function readDesiredIncomeNet(key, fallback = null) {
      const field = getDesiredIncomeField(key);
      if (!field) {
        return fallback;
      }
      const stored = field.dataset.netValue;
      if (typeof stored === 'string' && stored.trim() !== '') {
        const parsed = Number(stored);
        if (Number.isFinite(parsed)) {
          return parsed;
        }
      }
      const raw = field.value;
      if (typeof raw === 'string' && raw.trim() !== '') {
        const parsed = Number(raw);
        if (Number.isFinite(parsed)) {
          return parsed;
        }
      }
      return fallback;
    }

    function writeDesiredIncomeNet(key, value) {
      const field = getDesiredIncomeField(key);
      if (!field) {
        return;
      }
      if (Number.isFinite(value)) {
        field.dataset.netValue = String(value);
      } else {
        delete field.dataset.netValue;
      }
    }

    function captureDesiredIncomeNetValues() {
      return Object.keys(desiredIncomeFieldMap).reduce((accumulator, key) => {
        const value = readDesiredIncomeNet(key, null);
        if (Number.isFinite(value)) {
          accumulator[key] = value;
        }
        return accumulator;
      }, {});
    }

    function restoreDesiredIncomeNetValues(values) {
      if (!values || typeof values !== 'object') {
        return;
      }
      Object.entries(values).forEach(([key, value]) => {
        if (Number.isFinite(value)) {
          writeDesiredIncomeNet(key, value);
        }
      });
    }

    function convertGrossToNet(value, taxRate) {
      if (!Number.isFinite(value)) {
        return null;
      }
      const normalizedRate = Math.min(Math.max(taxRate, 0), 0.9999);
      return value * (1 - normalizedRate);
    }

    function convertNetToGross(value, taxRate) {
      if (!Number.isFinite(value)) {
        return null;
      }
      const normalizedRate = Math.min(Math.max(taxRate, 0), 0.9999);
      const denominator = Math.max(1 - normalizedRate, 0.0001);
      return value / denominator;
    }

    function setDesiredIncomeLockedGrossValue(key, value) {
      if (!desiredIncomeLockedAsGross) {
        return;
      }
      if (!Number.isFinite(value)) {
        if (
          desiredIncomeLockedGrossValues &&
          Object.prototype.hasOwnProperty.call(desiredIncomeLockedGrossValues, key)
        ) {
          delete desiredIncomeLockedGrossValues[key];
        }
        return;
      }
      if (!desiredIncomeLockedGrossValues) {
        desiredIncomeLockedGrossValues = {};
      }
      desiredIncomeLockedGrossValues[key] = Math.max(value, 0);
    }

    function getDesiredIncomeLockedGrossValue(key, fallback = null) {
      if (!desiredIncomeLockedGrossValues) {
        return fallback;
      }
      const stored = desiredIncomeLockedGrossValues[key];
      return Number.isFinite(stored) ? stored : fallback;
    }

    function clearDesiredIncomeLockedGrossStore() {
      desiredIncomeLockedGrossValues = null;
    }

    function setLockedAcceptableIncomeGross(type, value, basis = acceptableIncomeBasis) {
      if (!desiredIncomeLockedAsGross) {
        return;
      }
      const normalizedBasis = ACCEPTABLE_INCOME_BASIS_VALUES.includes(basis) ? basis : acceptableIncomeBasis;
      if (!Number.isFinite(value)) {
        if (type === 'min') {
          acceptableIncomeLockedGrossMin = null;
          acceptableIncomeLockedGrossMinBasis = null;
        } else if (type === 'max') {
          acceptableIncomeLockedGrossMax = null;
          acceptableIncomeLockedGrossMaxBasis = null;
        }
        return;
      }
      const normalized = Math.max(value, 0);
      if (type === 'min') {
        acceptableIncomeLockedGrossMin = normalized;
        acceptableIncomeLockedGrossMinBasis = normalizedBasis;
      } else if (type === 'max') {
        acceptableIncomeLockedGrossMax = normalized;
        acceptableIncomeLockedGrossMaxBasis = normalizedBasis;
      }
    }

    function getLockedAcceptableIncomeGross(type) {
      const value = type === 'min' ? acceptableIncomeLockedGrossMin : acceptableIncomeLockedGrossMax;
      const basis = type === 'min' ? acceptableIncomeLockedGrossMinBasis : acceptableIncomeLockedGrossMaxBasis;
      return {
        value: Number.isFinite(value) ? value : null,
        basis: ACCEPTABLE_INCOME_BASIS_VALUES.includes(basis) ? basis : null
      };
    }

    function clearLockedAcceptableIncomeGross() {
      acceptableIncomeLockedGrossMin = null;
      acceptableIncomeLockedGrossMax = null;
      acceptableIncomeLockedGrossMinBasis = null;
      acceptableIncomeLockedGrossMaxBasis = null;
    }

    function synchronizeLockedDesiredIncomeNetValues(taxRate) {
      if (!desiredIncomeLockedAsGross) {
        return;
      }

      Object.entries(desiredIncomeFieldMap).forEach(([key, field]) => {
        if (!(field instanceof HTMLInputElement)) {
          return;
        }

        const cached = getDesiredIncomeLockedGrossValue(key, null);
        let grossValue = Number.isFinite(cached) ? cached : null;

        const raw = typeof field.value === 'string' ? field.value.trim() : '';
        if (raw !== '') {
          const parsed = Number(raw);
          if (Number.isFinite(parsed)) {
            if (desiredIncomeDisplayMode === 'gross') {
              grossValue = Math.max(parsed, 0);
            } else {
              const derivedGross = convertNetToGross(parsed, taxRate);
              if (Number.isFinite(derivedGross)) {
                grossValue = Math.max(derivedGross, 0);
              }
            }
          }
        }

        if (!Number.isFinite(grossValue)) {
          writeDesiredIncomeNet(key, null);
          setDesiredIncomeLockedGrossValue(key, null);
          return;
        }

        const netValue = convertGrossToNet(grossValue, taxRate);
        if (!Number.isFinite(netValue)) {
          return;
        }

        writeDesiredIncomeNet(key, Math.max(netValue, 0));
        setDesiredIncomeLockedGrossValue(key, grossValue);
      });
    }

    function synchronizeLockedAcceptableIncomeNetValues(taxRate, activeMonths) {
      if (!desiredIncomeLockedAsGross) {
        return;
      }

      const months = Number.isFinite(activeMonths) && activeMonths > 0 ? activeMonths : MONTHS_PER_YEAR;

      const convertGrossBasisToAnnualNet = (grossValue, basis) => {
        if (!Number.isFinite(grossValue)) {
          return null;
        }
        const netBasis = convertGrossToNet(grossValue, taxRate);
        if (!Number.isFinite(netBasis)) {
          return null;
        }
        const effectiveBasis = ACCEPTABLE_INCOME_BASIS_VALUES.includes(basis)
          ? basis
          : acceptableIncomeBasis;
        if (effectiveBasis === 'annual') {
          return netBasis;
        }
        return netBasis * months;
      };

      const { value: minGross, basis: minBasis } = getLockedAcceptableIncomeGross('min');
      if (Number.isFinite(minGross)) {
        const annualNet = convertGrossBasisToAnnualNet(minGross, minBasis);
        acceptableIncomeMinAnnualNet = Number.isFinite(annualNet) ? Math.max(annualNet, 0) : null;
      } else {
        acceptableIncomeMinAnnualNet = null;
      }

      const { value: maxGross, basis: maxBasis } = getLockedAcceptableIncomeGross('max');
      if (Number.isFinite(maxGross)) {
        const annualNet = convertGrossBasisToAnnualNet(maxGross, maxBasis);
        acceptableIncomeMaxAnnualNet = Number.isFinite(annualNet) ? Math.max(annualNet, 0) : null;
      } else {
        acceptableIncomeMaxAnnualNet = null;
      }
    }

    const WEEKS_PER_YEAR = 52;
    const MONTHS_PER_YEAR = 12;
    const BASE_WORK_DAYS_PER_WEEK = 7;
    const TARGET_NET_DEFAULT = 50000;

    const ACCEPTABLE_INCOME_BASIS_VALUES = ['monthly', 'annual'];
    let acceptableIncomeBasis = 'monthly';
    let acceptableIncomeMinAnnualNet = null;
    let acceptableIncomeMaxAnnualNet = null;
    let previousAcceptableIncome = null;
    let lastActiveMonths = MONTHS_PER_YEAR;
    let lastWorkingWeeks = WEEKS_PER_YEAR;

    function updateDesiredIncomeTitle() {
      const isGross = desiredIncomeDisplayMode === 'gross';
      const title = isGross ? 'Desired Gross Income' : 'Desired Net Income';
      if (desiredIncomeTitle) {
        desiredIncomeTitle.textContent = title;
      }
      if (desiredIncomeLegend) {
        desiredIncomeLegend.textContent = isGross ? 'Desired gross income' : 'Desired net income';
      }
    }

    function updateDesiredIncomeLabels() {
      const isGross = desiredIncomeDisplayMode === 'gross';
      desiredIncomeLabelSpans.forEach(span => {
        const next = isGross ? span.dataset.grossLabel : span.dataset.netLabel;
        if (next) {
          span.textContent = next;
        }
      });
    }

    function updateDesiredIncomeTooltips() {
      const isGross = desiredIncomeDisplayMode === 'gross';
      desiredIncomeInfoIcons.forEach(icon => {
        if (!(icon instanceof HTMLElement)) {
          return;
        }
        const next = isGross ? icon.dataset.grossTooltip : icon.dataset.netTooltip;
        if (typeof next !== 'string') {
          return;
        }
        icon.dataset.tooltip = next;
        icon.setAttribute('aria-label', next);
        const parts = ensureInfoIconTooltip(icon);
        if (parts && parts.tooltip instanceof HTMLElement) {
          parts.tooltip.textContent = next;
        }
      });
    }

    function updateAcceptableIncomeBasisLabel() {
      if (!acceptableIncomeBasisLabel) {
        return;
      }
      const modeLabel = desiredIncomeDisplayMode === 'gross' ? 'Gross' : 'Net';
      const basisLabel = acceptableIncomeBasis === 'annual' ? 'Annual' : 'Monthly';
      acceptableIncomeBasisLabel.textContent = `${basisLabel} (${modeLabel})`;
    }

    function clearDesiredIncomeEditingState() {
      Object.values(desiredIncomeFieldMap).forEach(field => {
        if (field instanceof HTMLInputElement) {
          delete field.dataset.editing;
        }
      });
    }

    function clearAcceptableIncomeEditingState() {
      [controls.acceptableIncomeMin, controls.acceptableIncomeMax].forEach(field => {
        if (field instanceof HTMLInputElement) {
          delete field.dataset.editing;
        }
      });
    }

    function refreshDesiredIncomeDisplay(derivedNetValues, taxRate, options = {}) {
      const forceUpdate = options.force === true;
      updateDesiredIncomeTitle();
      updateDesiredIncomeLabels();
      updateAcceptableIncomeBasisLabel();
      updateDesiredIncomeTooltips();

      Object.entries(desiredIncomeFieldMap).forEach(([key, field]) => {
        if (!(field instanceof HTMLInputElement)) {
          return;
        }
        const isActiveBasis = targetNetBasis === key;
        let netValue = null;
        if (isActiveBasis) {
          const stored = readDesiredIncomeNet(key, null);
          if (Number.isFinite(stored)) {
            netValue = stored;
          } else if (Number.isFinite(derivedNetValues?.[key])) {
            netValue = derivedNetValues[key];
            writeDesiredIncomeNet(key, netValue);
          }
        } else if (Number.isFinite(derivedNetValues?.[key])) {
          netValue = derivedNetValues[key];
          writeDesiredIncomeNet(key, netValue);
        } else {
          netValue = null;
          writeDesiredIncomeNet(key, null);
        }

        const isEditing = field.dataset.editing === 'true';

        if (!Number.isFinite(netValue)) {
          if (!isEditing || forceUpdate) {
            field.value = '';
          }
          return;
        }

        const displayValue = desiredIncomeDisplayMode === 'gross'
          ? convertNetToGross(netValue, taxRate)
          : netValue;

        if (isEditing && !forceUpdate) {
          return;
        }

        field.value = formatFixed(displayValue, 2);
      });
    }

    function refreshAcceptableIncomeDisplay(taxRate, options = {}) {
      const forceUpdate = options.force === true;
      updateAcceptableIncomeBasisLabel();
      const minInput = controls.acceptableIncomeMin instanceof HTMLInputElement
        ? controls.acceptableIncomeMin
        : null;
      const maxInput = controls.acceptableIncomeMax instanceof HTMLInputElement
        ? controls.acceptableIncomeMax
        : null;
      const monthsForRange = lastActiveMonths > 0 ? lastActiveMonths : MONTHS_PER_YEAR;

      const toDisplay = annualNet => {
        if (!Number.isFinite(annualNet)) {
          return '';
        }
        const netBasis = acceptableIncomeBasis === 'annual'
          ? annualNet
          : annualNet / monthsForRange;
        const value = desiredIncomeDisplayMode === 'gross'
          ? convertNetToGross(netBasis, taxRate)
          : netBasis;
        return Number.isFinite(value) ? formatFixed(value, 2) : '';
      };

      if (minInput) {
        if (minInput.dataset.editing === 'true' && !forceUpdate) {
          // Keep the user's in-progress value.
        } else {
          minInput.value = toDisplay(acceptableIncomeMinAnnualNet);
        }
      }
      if (maxInput) {
        if (maxInput.dataset.editing === 'true' && !forceUpdate) {
          // Keep the user's in-progress value.
        } else {
          maxInput.value = toDisplay(acceptableIncomeMaxAnnualNet);
        }
      }
    }

    function initializeDesiredIncomeDatasets() {
      Object.entries(desiredIncomeFieldMap).forEach(([key, field]) => {
        if (!(field instanceof HTMLInputElement)) {
          return;
        }
        const raw = typeof field.value === 'string' ? field.value.trim() : '';
        if (raw === '') {
          writeDesiredIncomeNet(key, null);
          return;
        }
        const parsed = Number(raw);
        if (Number.isFinite(parsed)) {
          writeDesiredIncomeNet(key, Math.max(parsed, 0));
        }
      });
    }

    function updateDesiredIncomeFromField(basis) {
      const field = getDesiredIncomeField(basis);
      if (!(field instanceof HTMLInputElement)) {
        return;
      }
      const raw = typeof field.value === 'string' ? field.value.trim() : '';
      if (raw === '') {
        writeDesiredIncomeNet(basis, null);
        if (desiredIncomeLockedAsGross) {
          setDesiredIncomeLockedGrossValue(basis, null);
        } else if (desiredIncomeLockedGrossValues) {
          delete desiredIncomeLockedGrossValues[basis];
        }
        return;
      }
      const parsed = Number(raw);
      if (!Number.isFinite(parsed)) {
        if (desiredIncomeLockedAsGross) {
          setDesiredIncomeLockedGrossValue(basis, null);
        }
        return;
      }
      const taxRate = getCurrentTaxRate();
      const netValue = desiredIncomeDisplayMode === 'gross'
        ? convertGrossToNet(parsed, taxRate)
        : parsed;
      writeDesiredIncomeNet(basis, Math.max(netValue, 0));
      if (desiredIncomeLockedAsGross) {
        const grossForStore = desiredIncomeDisplayMode === 'gross'
          ? parsed
          : convertNetToGross(parsed, taxRate);
        if (Number.isFinite(grossForStore)) {
          setDesiredIncomeLockedGrossValue(basis, Math.max(grossForStore, 0));
        } else {
          setDesiredIncomeLockedGrossValue(basis, null);
        }
      } else if (desiredIncomeLockedGrossValues) {
        delete desiredIncomeLockedGrossValues[basis];
      }
    }

    function updateAcceptableIncomeFromInput(type) {
      const input = type === 'min' ? controls.acceptableIncomeMin : controls.acceptableIncomeMax;
      if (!(input instanceof HTMLInputElement)) {
        return;
      }
      const raw = typeof input.value === 'string' ? input.value.trim() : '';
      if (raw === '') {
        if (type === 'min') {
          acceptableIncomeMinAnnualNet = null;
        } else {
          acceptableIncomeMaxAnnualNet = null;
        }
        if (desiredIncomeLockedAsGross) {
          setLockedAcceptableIncomeGross(type, null);
        }
        return;
      }
      const parsed = Number(raw);
      if (!Number.isFinite(parsed)) {
        if (desiredIncomeLockedAsGross) {
          setLockedAcceptableIncomeGross(type, null);
        }
        return;
      }
      const taxRate = getCurrentTaxRate();
      const netValue = desiredIncomeDisplayMode === 'gross'
        ? convertGrossToNet(parsed, taxRate)
        : parsed;
      const normalizedNet = Math.max(netValue, 0);
      if (desiredIncomeLockedAsGross) {
        const grossForStore = desiredIncomeDisplayMode === 'gross'
          ? parsed
          : convertNetToGross(parsed, taxRate);
        if (Number.isFinite(grossForStore)) {
          setLockedAcceptableIncomeGross(type, Math.max(grossForStore, 0), acceptableIncomeBasis);
        } else {
          setLockedAcceptableIncomeGross(type, null);
        }
      }
      const months = lastActiveMonths > 0 ? lastActiveMonths : MONTHS_PER_YEAR;
      const annualNet = acceptableIncomeBasis === 'annual'
        ? normalizedNet
        : normalizedNet * months;
      if (type === 'min') {
        acceptableIncomeMinAnnualNet = Number.isFinite(annualNet) ? annualNet : null;
      } else {
        acceptableIncomeMaxAnnualNet = Number.isFinite(annualNet) ? annualNet : null;
      }
      previousAcceptableIncome = null;
    }

    const desiredIncomeTitle = document.getElementById('desired-income-title');
    const desiredIncomeLegend = document.getElementById('section-desired-income-legend');
    const acceptableIncomeBasisLabel = document.getElementById('acceptable-income-current-basis');
    const desiredIncomeLabelSpans = Array.from(
      document.querySelectorAll('#section-desired-income .label-text[data-net-label][data-gross-label]')
    );
    const desiredIncomeInfoIcons = Array.from(
      document.querySelectorAll('#section-desired-income .info-icon[data-net-tooltip][data-gross-tooltip]')
    );

    const fixedCostFields = {
      location: {
        monthly: document.getElementById('fixed-cost-location-monthly'),
        annual: document.getElementById('fixed-cost-location-annual')
      },
      insurance: {
        monthly: document.getElementById('fixed-cost-insurance-monthly'),
        annual: document.getElementById('fixed-cost-insurance-annual')
      },
      disability: {
        monthly: document.getElementById('fixed-cost-disability-monthly'),
        annual: document.getElementById('fixed-cost-disability-annual')
      },
      health: {
        monthly: document.getElementById('fixed-cost-health-monthly'),
        annual: document.getElementById('fixed-cost-health-annual')
      },
      pension: {
        monthly: document.getElementById('fixed-cost-pension-monthly'),
        annual: document.getElementById('fixed-cost-pension-annual')
      },
      marketing: {
        monthly: document.getElementById('fixed-cost-marketing-monthly'),
        annual: document.getElementById('fixed-cost-marketing-annual')
      },
      materials: {
        monthly: document.getElementById('fixed-cost-materials-monthly'),
        annual: document.getElementById('fixed-cost-materials-annual')
      },
      admin: {
        monthly: document.getElementById('fixed-cost-admin-monthly'),
        annual: document.getElementById('fixed-cost-admin-annual')
      },
      development: {
        monthly: document.getElementById('fixed-cost-development-monthly'),
        annual: document.getElementById('fixed-cost-development-annual')
      }
    };

    controls.fixedCostFields = fixedCostFields;

    const rememberInputsToggle = controls.rememberInputs instanceof HTMLInputElement ? controls.rememberInputs : null;
    const resetSavedInputsButton = controls.resetSavedInputs instanceof HTMLButtonElement ? controls.resetSavedInputs : null;
    const PERSISTENCE_ENABLED_KEY = 'income-calculator-save-enabled';
    const PERSISTENCE_VALUES_KEY = 'income-calculator-saved-inputs';
    let persistenceEnabled = false;
    let persistableInputsCache = null;

    initializeDesiredIncomeDatasets();
    updateDesiredIncomeTitle();
    updateDesiredIncomeLabels();
    updateAcceptableIncomeBasisLabel();

    function getPersistableInputs() {
      if (persistableInputsCache) {
        return persistableInputsCache;
      }
      const container = document.querySelector('.card.controls');
      if (!(container instanceof HTMLElement)) {
        persistableInputsCache = [];
        return persistableInputsCache;
      }
      persistableInputsCache = Array.from(container.querySelectorAll('input')).filter(input => {
        return input instanceof HTMLInputElement && input.type !== 'button' && input.id !== 'remember-inputs';
      });
      return persistableInputsCache;
    }

    function captureInputValues(inputs = getPersistableInputs()) {
      const values = inputs.reduce((accumulator, input) => {
        if (!(input instanceof HTMLInputElement) || !input.id) {
          return accumulator;
        }
        if (input.type === 'checkbox' || input.type === 'radio') {
          accumulator[input.id] = input.checked;
        } else {
          accumulator[input.id] = input.value;
        }
        return accumulator;
      }, {});
      values[PERSISTED_TARGET_NET_BASIS_KEY] = targetNetBasis;
      values[PERSISTED_DESIRED_INCOME_DISPLAY_KEY] = desiredIncomeDisplayMode;
      values[PERSISTED_DESIRED_INCOME_LOCK_KEY] = desiredIncomeLockedAsGross;
      values[PERSISTED_ACCEPTABLE_INCOME_MIN_KEY] = Number.isFinite(acceptableIncomeMinAnnualNet)
        ? acceptableIncomeMinAnnualNet
        : null;
      values[PERSISTED_ACCEPTABLE_INCOME_MAX_KEY] = Number.isFinite(acceptableIncomeMaxAnnualNet)
        ? acceptableIncomeMaxAnnualNet
        : null;
      values[PERSISTED_ACCEPTABLE_INCOME_BASIS_KEY] = acceptableIncomeBasis;
      values[PERSISTED_COLLAPSED_SECTIONS_KEY] = captureCollapsibleSectionStates();
      values.__customCosts = customCosts.map(cost => ({
        id: cost.id,
        name: cost.name,
        amount: Number(cost.amount),
        frequency: cost.frequency
      }));
      Object.keys(desiredIncomeFieldMap).forEach(key => {
        const netValue = readDesiredIncomeNet(key, null);
        values[`__desiredIncomeNet_${key}`] = Number.isFinite(netValue) ? netValue : null;
      });
      return values;
    }

    const defaultInputValues = captureInputValues();

    function readPersistenceEnabled() {
      try {
        return localStorage.getItem(PERSISTENCE_ENABLED_KEY) === 'true';
      } catch (error) {
        return false;
      }
    }

    function readPersistedValues() {
      try {
        const raw = localStorage.getItem(PERSISTENCE_VALUES_KEY);
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
          return parsed;
        }
      } catch (error) {
        // Ignore parsing errors
      }
      return null;
    }

    function clearPersistedInputs() {
      try {
        localStorage.removeItem(PERSISTENCE_VALUES_KEY);
        localStorage.removeItem(PERSISTENCE_ENABLED_KEY);
      } catch (error) {
        // Ignore storage errors
      }
    }

    function applyInputValues(values, options = {}) {
      const { skipRender = false } = options;
      if (!values || typeof values !== 'object') {
        return;
      }
      const storedBasis = values[PERSISTED_TARGET_NET_BASIS_KEY];
      if (typeof storedBasis === 'string' && TARGET_NET_BASIS_VALUES.includes(storedBasis)) {
        targetNetBasis = storedBasis;
      }
      const storedDisplay = values[PERSISTED_DESIRED_INCOME_DISPLAY_KEY];
      if (storedDisplay === 'gross' || storedDisplay === 'net') {
        desiredIncomeDisplayMode = storedDisplay;
      }
      desiredIncomeLockedAsGross = Boolean(values[PERSISTED_DESIRED_INCOME_LOCK_KEY]);
      const storedAcceptableBasis = values[PERSISTED_ACCEPTABLE_INCOME_BASIS_KEY];
      if (typeof storedAcceptableBasis === 'string' && ACCEPTABLE_INCOME_BASIS_VALUES.includes(storedAcceptableBasis)) {
        acceptableIncomeBasis = storedAcceptableBasis;
      }
      const storedAcceptableMinRaw = values[PERSISTED_ACCEPTABLE_INCOME_MIN_KEY];
      if (storedAcceptableMinRaw === null || typeof storedAcceptableMinRaw === 'undefined') {
        acceptableIncomeMinAnnualNet = null;
      } else {
        const storedAcceptableMin = Number(storedAcceptableMinRaw);
        acceptableIncomeMinAnnualNet = Number.isFinite(storedAcceptableMin) ? storedAcceptableMin : null;
      }
      const storedAcceptableMaxRaw = values[PERSISTED_ACCEPTABLE_INCOME_MAX_KEY];
      if (storedAcceptableMaxRaw === null || typeof storedAcceptableMaxRaw === 'undefined') {
        acceptableIncomeMaxAnnualNet = null;
      } else {
        const storedAcceptableMax = Number(storedAcceptableMaxRaw);
        // Only coerce persisted values when they exist so blanks reload as an open range.
        acceptableIncomeMaxAnnualNet = Number.isFinite(storedAcceptableMax) ? storedAcceptableMax : null;
      }
      const inputs = getPersistableInputs();
      inputs.forEach(input => {
        if (!(input instanceof HTMLInputElement) || !input.id) {
          return;
        }
        if (!Object.prototype.hasOwnProperty.call(values, input.id)) {
          return;
        }
        const storedValue = values[input.id];
        if (input.type === 'checkbox' || input.type === 'radio') {
          input.checked = Boolean(storedValue);
        } else {
          input.value = storedValue === null || typeof storedValue === 'undefined'
            ? ''
            : String(storedValue);
        }
      });
      Object.keys(desiredIncomeFieldMap).forEach(key => {
        const storedNetKey = `__desiredIncomeNet_${key}`;
        const storedNet = Number(values[storedNetKey]);
        if (Number.isFinite(storedNet)) {
          writeDesiredIncomeNet(key, Math.max(storedNet, 0));
          return;
        }
        const field = getDesiredIncomeField(key);
        if (!(field instanceof HTMLInputElement)) {
          writeDesiredIncomeNet(key, null);
          return;
        }
        const raw = typeof field.value === 'string' ? field.value.trim() : '';
        if (raw === '') {
          writeDesiredIncomeNet(key, null);
          return;
        }
        const parsed = Number(raw);
        if (!Number.isFinite(parsed)) {
          writeDesiredIncomeNet(key, null);
          return;
        }
        const taxRate = getCurrentTaxRate();
        const netValue = desiredIncomeDisplayMode === 'gross'
          ? convertGrossToNet(parsed, taxRate)
          : parsed;
        writeDesiredIncomeNet(key, Math.max(netValue, 0));
      });
      if (desiredIncomeLockedAsGross) {
        synchronizeLockedDesiredIncomeNetValues(getCurrentTaxRate());
        updateAcceptableIncomeFromInput('min');
        updateAcceptableIncomeFromInput('max');
      } else {
        clearDesiredIncomeLockedGrossStore();
        clearLockedAcceptableIncomeGross();
      }
      const storedCollapsedStates = values[PERSISTED_COLLAPSED_SECTIONS_KEY];
      if (storedCollapsedStates && typeof storedCollapsedStates === 'object') {
        applyCollapsibleSectionStates(storedCollapsedStates, { skipPersistence: true });
      }
      updateDesiredIncomeTitle();
      updateDesiredIncomeLabels();
      updateAcceptableIncomeBasisLabel();
      const storedCustomCosts = Array.isArray(values.__customCosts) ? values.__customCosts : [];
      customCostIdCounter = 0;
      customCosts = storedCustomCosts
        .filter(entry => entry && typeof entry.name === 'string')
        .map(entry => {
          const amountValue = Number(entry.amount);
          const frequencyValue = entry.frequency === 'annual' ? 'annual' : 'monthly';
          const parsedAmount = Number.isFinite(amountValue) ? Math.max(amountValue, 0) : 0;
          let idValue = null;
          if (typeof entry.id === 'string') {
            const idMatch = entry.id.match(/custom-(\d+)/);
            if (idMatch) {
              const parsedId = Number(idMatch[1]);
              if (Number.isFinite(parsedId)) {
                customCostIdCounter = Math.max(customCostIdCounter, parsedId);
                idValue = entry.id;
              }
            }
          }
          if (!idValue) {
            customCostIdCounter += 1;
            idValue = `custom-${customCostIdCounter}`;
          }
          return {
            id: idValue,
            name: entry.name,
            amount: parsedAmount,
            frequency: frequencyValue
          };
        });
      renderCustomCostList();
      updateFixedCostTotalDisplay();
      if (!skipRender) {
        render();
      }
    }

    function savePersistedInputs() {
      if (!persistenceEnabled) {
        return;
      }
      try {
        const values = captureInputValues();
        localStorage.setItem(PERSISTENCE_VALUES_KEY, JSON.stringify(values));
        localStorage.setItem(PERSISTENCE_ENABLED_KEY, 'true');
      } catch (error) {
        persistenceEnabled = false;
        if (rememberInputsToggle) {
          rememberInputsToggle.checked = false;
        }
      }
    }

    function persistCustomCosts() {
      if (persistenceEnabled) {
        savePersistedInputs();
      }
    }

    function handlePersistableInputMutation(event) {
      if (event && event.target instanceof HTMLInputElement) {
        const nextBasis = TARGET_NET_BASIS_BY_INPUT_ID[event.target.id];
        if (typeof nextBasis === 'string') {
          targetNetBasis = nextBasis;
        }
      }
      if (persistenceEnabled) {
        savePersistedInputs();
      }
    }

    function initializePersistence() {
      if (rememberInputsToggle) {
        rememberInputsToggle.checked = readPersistenceEnabled();
        persistenceEnabled = rememberInputsToggle.checked;
      } else {
        persistenceEnabled = false;
      }

      const storedValues = persistenceEnabled ? readPersistedValues() : null;
      if (storedValues) {
        applyInputValues(storedValues, { skipRender: true });
      }

      getPersistableInputs().forEach(input => {
        input.addEventListener('input', handlePersistableInputMutation);
        input.addEventListener('change', handlePersistableInputMutation);
      });

      if (rememberInputsToggle) {
        rememberInputsToggle.addEventListener('change', () => {
          persistenceEnabled = rememberInputsToggle.checked;
          if (persistenceEnabled) {
            savePersistedInputs();
          } else {
            clearPersistedInputs();
          }
        });
      }

      if (resetSavedInputsButton) {
        resetSavedInputsButton.addEventListener('click', () => {
          applyInputValues(defaultInputValues);
          if (persistenceEnabled) {
            savePersistedInputs();
          } else {
            clearPersistedInputs();
          }
        });
      }
    }

    const tablesContainer = document.getElementById('tables-container');
    const variableControlsContainer = document.getElementById('variable-controls');
    let tablesLayoutUpdateScheduled = false;
    const assumptionsList = document.getElementById('assumptions-list');

    const INFO_ICON_ACTIVE_CLASS = 'is-active';
    const TOOLTIP_VIEWPORT_PADDING = 16;
    let activeInfoIcon = null;
    let infoIconTooltipId = 0;

    function isInfoIcon(element) {
      return element instanceof HTMLElement && element.classList.contains('info-icon');
    }

    function ensureInfoIconTooltip(icon) {
      if (!isInfoIcon(icon)) {
        return null;
      }
      let tooltip = icon.querySelector('.info-icon__tooltip');
      if (!(tooltip instanceof HTMLElement)) {
        tooltip = document.createElement('span');
        tooltip.className = 'info-icon__tooltip';
        tooltip.setAttribute('role', 'tooltip');
        icon.append(tooltip);
      }
      let arrow = icon.querySelector('.info-icon__arrow');
      if (!(arrow instanceof HTMLElement)) {
        arrow = document.createElement('span');
        arrow.className = 'info-icon__arrow';
        arrow.setAttribute('aria-hidden', 'true');
        icon.append(arrow);
      }
      const tooltipText = icon.dataset.tooltip || icon.getAttribute('aria-label') || '';
      tooltip.textContent = tooltipText;
      if (!tooltip.id) {
        infoIconTooltipId += 1;
        tooltip.id = `info-icon-tooltip-${infoIconTooltipId}`;
      }
      if (!icon.hasAttribute('aria-describedby')) {
        icon.setAttribute('aria-describedby', tooltip.id);
      }
      return { tooltip, arrow };
    }

    function positionInfoIconTooltip(icon) {
      if (!isInfoIcon(icon)) {
        return;
      }
      const parts = ensureInfoIconTooltip(icon);
      if (!parts || !(parts.tooltip instanceof HTMLElement)) {
        return;
      }
      icon.style.setProperty('--tooltip-shift', '0px');
      const tooltipRect = parts.tooltip.getBoundingClientRect();
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
      const padding = TOOLTIP_VIEWPORT_PADDING;
      let shift = 0;
      if (tooltipRect.left < padding) {
        shift = padding - tooltipRect.left;
      } else if (tooltipRect.right > viewportWidth - padding) {
        shift = -(tooltipRect.right - (viewportWidth - padding));
      }
      icon.style.setProperty('--tooltip-shift', `${shift}px`);
    }

    function enhanceInfoIcon(icon) {
      if (!isInfoIcon(icon)) {
        return;
      }
      if (!icon.hasAttribute('tabindex')) {
        icon.setAttribute('tabindex', '0');
      }
      icon.setAttribute('role', 'button');
      icon.setAttribute('aria-expanded', icon.classList.contains(INFO_ICON_ACTIVE_CLASS) ? 'true' : 'false');
      if (!icon.hasAttribute('aria-label') && icon.dataset.tooltip) {
        icon.setAttribute('aria-label', icon.dataset.tooltip);
      }
      ensureInfoIconTooltip(icon);
    }

    function enhanceAllInfoIcons() {
      document.querySelectorAll('.info-icon').forEach(enhanceInfoIcon);
    }

    function closeActiveInfoIcon() {
      if (activeInfoIcon instanceof HTMLElement) {
        activeInfoIcon.classList.remove(INFO_ICON_ACTIVE_CLASS);
        activeInfoIcon.setAttribute('aria-expanded', 'false');
      }
      activeInfoIcon = null;
    }

    function openInfoIcon(icon) {
      if (!isInfoIcon(icon)) {
        return;
      }
      if (activeInfoIcon && activeInfoIcon !== icon) {
        closeActiveInfoIcon();
      }
      icon.classList.add(INFO_ICON_ACTIVE_CLASS);
      icon.setAttribute('aria-expanded', 'true');
      activeInfoIcon = icon;
      positionInfoIconTooltip(icon);
    }

    function toggleInfoIcon(icon) {
      if (!isInfoIcon(icon)) {
        return;
      }
      if (icon.classList.contains(INFO_ICON_ACTIVE_CLASS)) {
        if (activeInfoIcon === icon) {
          closeActiveInfoIcon();
        } else {
          icon.classList.remove(INFO_ICON_ACTIVE_CLASS);
          icon.setAttribute('aria-expanded', 'false');
        }
      } else {
        openInfoIcon(icon);
      }
    }

    document.addEventListener('click', event => {
      const target = event.target instanceof HTMLElement ? event.target.closest('.info-icon') : null;
      if (!isInfoIcon(target)) {
        closeActiveInfoIcon();
        return;
      }
      event.preventDefault();
      enhanceInfoIcon(target);
      toggleInfoIcon(target);
      positionInfoIconTooltip(target);
      if (typeof target.focus === 'function') {
        target.focus();
      }
    });

    document.addEventListener('keydown', event => {
      if (event.key === 'Escape') {
        if (activeInfoIcon) {
          event.preventDefault();
          const current = activeInfoIcon;
          closeActiveInfoIcon();
          if (current instanceof HTMLElement && typeof current.focus === 'function') {
            current.focus();
          }
        }
        return;
      }

      const target = event.target instanceof HTMLElement ? event.target.closest('.info-icon') : null;
      if (!isInfoIcon(target)) {
        return;
      }

      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        enhanceInfoIcon(target);
        toggleInfoIcon(target);
        positionInfoIconTooltip(target);
      }
    });

    document.addEventListener('focusin', event => {
      const target = event.target instanceof HTMLElement ? event.target.closest('.info-icon') : null;
      if (!isInfoIcon(target)) {
        closeActiveInfoIcon();
        return;
      }
      enhanceInfoIcon(target);
      positionInfoIconTooltip(target);
    });

    enhanceAllInfoIcons();

    document.addEventListener('mouseover', event => {
      const target = event.target instanceof HTMLElement ? event.target.closest('.info-icon') : null;
      if (!isInfoIcon(target)) {
        return;
      }
      positionInfoIconTooltip(target);
    });

    window.addEventListener('resize', () => {
      if (activeInfoIcon) {
        positionInfoIconTooltip(activeInfoIcon);
      }
    });

    function formatFixed(value, fractionDigits = 1) {
      const fixed = value.toFixed(fractionDigits);
      return fixed
        .replace(/\.0+$/, '')
        .replace(/(\.[0-9]*[1-9])0+$/, '$1');
    }

    function parseNumber(value, fallback = 0, { min = -Infinity, max = Infinity } = {}) {
      if (value === null || value === undefined) {
        return fallback;
      }
      const normalized = typeof value === 'string' ? value.trim() : value;
      if (normalized === '') {
        return fallback;
      }
      const parsed = Number(normalized);
      if (!Number.isFinite(parsed)) {
        return fallback;
      }
      return Math.min(Math.max(parsed, min), max);
    }

    function getCurrentTaxRate() {
      const percent = Math.min(Math.max(parseNumber(controls.taxRate?.value, 40), 0), 99.9);
      return percent / 100;
    }

    function parseNumberList(value, { min = -Infinity, max = Infinity, allowZero = false } = {}) {
      if (!value) {
        return [];
      }

      const values = new Set();
      const tokens = value
        .split(',')
        .map(token => token.trim())
        .filter(token => token.length > 0);

      const getDecimalPlaces = value => {
        const decimalPart = value.split('.')[1];
        return decimalPart ? decimalPart.length : 0;
      };

      tokens.forEach(token => {
        const rangeMatch = token.match(/^(-?\d+(?:\.\d+)?)\s*-\s*(-?\d+(?:\.\d+)?)$/);
        if (rangeMatch) {
          const [ , startToken, endToken ] = rangeMatch;
          const startValue = Number(startToken);
          const endValue = Number(endToken);
          if (!Number.isFinite(startValue) || !Number.isFinite(endValue)) {
            return;
          }

          const rangeStart = Math.min(startValue, endValue);
          const rangeEnd = Math.max(startValue, endValue);
          const decimalPlaces = Math.max(getDecimalPlaces(startToken), getDecimalPlaces(endToken));
          const step = decimalPlaces > 0 ? Math.pow(10, -decimalPlaces) : 1;
          const precision = Math.max(decimalPlaces, 6);

          for (let current = rangeStart; current <= rangeEnd + step / 2; current = Number((current + step).toFixed(precision))) {
            const normalized = Number(current.toFixed(precision));
            const meetsZeroRule = allowZero ? normalized >= 0 : normalized > 0;
            if (!meetsZeroRule) {
              continue;
            }
            if (normalized < min || normalized > max) {
              continue;
            }
            values.add(normalized);
          }
          return;
        }

        const parsed = Number(token);
        if (!Number.isFinite(parsed)) {
          return;
        }
        const meetsZeroRule = allowZero ? parsed >= 0 : parsed > 0;
        if (!meetsZeroRule) {
          return;
        }
        if (parsed < min || parsed > max) {
          return;
        }
        values.add(parsed);
      });

      return Array.from(values).sort((a, b) => a - b);
    }

    (function runParseNumberListChecks() {
      if (typeof console === 'undefined' || typeof console.assert !== 'function') {
        return;
      }

      const arrayEquals = (left, right) =>
        left.length === right.length && left.every((value, index) => value === right[index]);

      console.assert(
        arrayEquals(parseNumberList('6-10', { allowZero: true }), [6, 7, 8, 9, 10]),
        'parseNumberList should include integer ranges'
      );

      console.assert(
        arrayEquals(parseNumberList('0-2', { allowZero: true }), [0, 1, 2]),
        'parseNumberList should include zero when allowed'
      );

      const fractionalRange = parseNumberList('0.5-2');
      console.assert(
        fractionalRange[0] === 0.5 &&
          fractionalRange[1] === 0.6 &&
          fractionalRange[fractionalRange.length - 1] === 2,
        'parseNumberList should respect fractional increments'
      );
    })();

    function parseList(value) {
      if (!value) {
        return [];
      }

      const values = [];
      const tokens = value
        .split(',')
        .map(token => token.trim())
        .filter(token => token.length > 0);

      tokens.forEach(token => {
        const rangeMatch = token.match(/^(-?\d+(?:\.\d+)?)\s*-\s*(-?\d+(?:\.\d+)?)$/);
        if (rangeMatch) {
          const startValue = Math.round(Number(rangeMatch[1]));
          const endValue = Math.round(Number(rangeMatch[2]));
          if (!Number.isFinite(startValue) || !Number.isFinite(endValue)) {
            return;
          }

          const rangeStart = Math.min(startValue, endValue);
          const rangeEnd = Math.max(startValue, endValue);
          for (let current = rangeStart; current <= rangeEnd; current += 1) {
            if (current > 0) {
              values.push(current);
            }
          }
          return;
        }

        const parsed = Math.round(Number(token));
        if (Number.isFinite(parsed) && parsed > 0) {
          values.push(parsed);
        }
      });

      return Array.from(new Set(values)).sort((a, b) => a - b);
    }

    function updateTablesLayout() {
      if (!tablesContainer) {
        return;
      }

      const cards = tablesContainer.querySelectorAll('.card');
      if (cards.length <= 1) {
        tablesContainer.classList.remove('table-grid--stacked');
        return;
      }

      const hasOverflow = tablesContainer.scrollWidth > tablesContainer.clientWidth + 1;
      tablesContainer.classList.toggle('table-grid--stacked', hasOverflow);
    }

    function scheduleTablesLayoutUpdate() {
      if (!tablesContainer) {
        return;
      }
      if (tablesLayoutUpdateScheduled) {
        return;
      }

      tablesLayoutUpdateScheduled = true;
      requestAnimationFrame(() => {
        tablesLayoutUpdateScheduled = false;
        updateTablesLayout();
      });
    }

    function getFixedCostTotal() {
      const fixedTotal = Object.values(fixedCostFields).reduce((sum, fieldSet) => {
        if (!(fieldSet.annual instanceof HTMLInputElement)) {
          return sum;
        }
        const annualValue = Math.max(parseNumber(fieldSet.annual.value, 0), 0);
        return sum + annualValue;
      }, 0);
      const customTotal = customCosts.reduce((sum, cost) => {
        const annualAmount = computeCustomCostAnnualAmount(cost);
        return sum + annualAmount;
      }, 0);
      return fixedTotal + customTotal;
    }

    function computeCustomCostAnnualAmount(cost) {
      if (!cost || typeof cost !== 'object') {
        return 0;
      }
      const amount = Number(cost.amount);
      if (!Number.isFinite(amount) || amount <= 0) {
        return 0;
      }
      return cost.frequency === 'annual' ? amount : amount * 12;
    }

    function renderCustomCostList() {
      const list = controls.customCostList;
      if (!(list instanceof HTMLElement)) {
        return;
      }

      if (!customCosts.length) {
        list.innerHTML = '<p class="field-note">No additional costs added yet.</p>';
        return;
      }

      const symbol = controls.currencySymbol?.value?.trim() || '€';

      list.innerHTML = customCosts
        .map(cost => {
          const annualAmount = computeCustomCostAnnualAmount(cost);
          const amountDisplay = cost.frequency === 'annual'
            ? `${formatCurrencyDetailed(symbol, cost.amount)} per year`
            : `${formatCurrencyDetailed(symbol, cost.amount)} per month`;
          const annualDisplay = `${formatCurrencyDetailed(symbol, annualAmount)} annually`;
          const safeName = escapeHtml(cost.name || 'Custom cost');
          return `
            <div class="custom-costs__item" role="listitem">
              <div class="custom-costs__item-info">
                <strong>${safeName}</strong>
                <span>${amountDisplay} · ${annualDisplay}</span>
              </div>
              <button type="button" data-cost-id="${escapeHtml(cost.id)}">Remove</button>
            </div>
          `;
        })
        .join('');
    }

    function showStatusMessage(message, timeout = 2500) {
      if (!(controls.statusMessage instanceof HTMLElement)) {
        return;
      }
      controls.statusMessage.textContent = message;
      if (timeout > 0) {
        window.setTimeout(() => {
          if (controls.statusMessage && controls.statusMessage.textContent === message) {
            controls.statusMessage.textContent = '';
          }
        }, timeout);
      }
    }

    function clearStatusMessage() {
      if (controls.statusMessage instanceof HTMLElement) {
        controls.statusMessage.textContent = '';
      }
    }

    function resetCustomCostInputs() {
      if (controls.customCostName instanceof HTMLInputElement) {
        controls.customCostName.value = '';
      }
      if (controls.customCostAmount instanceof HTMLInputElement) {
        controls.customCostAmount.value = '';
      }
      if (controls.customCostFrequency instanceof HTMLSelectElement) {
        controls.customCostFrequency.value = 'monthly';
      }
    }

    function handleAddCustomCost() {
      const nameInput = controls.customCostName;
      const amountInput = controls.customCostAmount;
      const frequencySelect = controls.customCostFrequency;
      if (
        !(nameInput instanceof HTMLInputElement) ||
        !(amountInput instanceof HTMLInputElement) ||
        !(frequencySelect instanceof HTMLSelectElement)
      ) {
        return;
      }

      const name = nameInput.value.trim();
      const amountValue = Number(amountInput.value);
      const frequency = frequencySelect.value === 'annual' ? 'annual' : 'monthly';

      if (!name) {
        showStatusMessage('Enter a description for the cost.');
        return;
      }

      if (!Number.isFinite(amountValue) || amountValue < 0) {
        showStatusMessage('Enter a valid amount for the custom cost.');
        return;
      }

      customCostIdCounter += 1;
      const costEntry = {
        id: `custom-${customCostIdCounter}`,
        name,
        amount: amountValue,
        frequency
      };

      customCosts.push(costEntry);
      resetCustomCostInputs();
      renderCustomCostList();
      updateFixedCostTotalDisplay();
      clearStatusMessage();
      persistCustomCosts();
      render();
    }

    function removeCustomCost(costId) {
      const nextCosts = customCosts.filter(cost => cost.id !== costId);
      if (nextCosts.length === customCosts.length) {
        return;
      }
      customCosts = nextCosts;
      renderCustomCostList();
      updateFixedCostTotalDisplay();
      persistCustomCosts();
      render();
    }

    function updateFixedCostTotalDisplay() {
      const total = getFixedCostTotal();
      if (controls.fixedCosts instanceof HTMLInputElement) {
        controls.fixedCosts.value = formatFixed(total, 2);
      }
      return total;
    }

    function syncFixedCostPair(key, sourceType) {
      const fieldSet = fixedCostFields[key];
      if (!fieldSet) {
        return;
      }
      const source = sourceType === 'monthly' ? fieldSet.monthly : fieldSet.annual;
      const target = sourceType === 'monthly' ? fieldSet.annual : fieldSet.monthly;
      if (!(source instanceof HTMLInputElement) || !(target instanceof HTMLInputElement)) {
        return;
      }

      if (source.value === '') {
        target.value = '';
        updateFixedCostTotalDisplay();
        return;
      }

      const parsed = Math.max(parseNumber(source.value, 0), 0);
      const derived = sourceType === 'monthly' ? parsed * 12 : parsed / 12;

      if (Number.isFinite(derived)) {
        target.value = formatFixed(derived, 2);
      }

      updateFixedCostTotalDisplay();
    }

    Object.entries(fixedCostFields).forEach(([key, fieldSet]) => {
      const { monthly, annual } = fieldSet;
      if (monthly instanceof HTMLInputElement) {
        monthly.addEventListener('input', () => {
          syncFixedCostPair(key, 'monthly');
          render();
        });
        monthly.addEventListener('change', () => {
          syncFixedCostPair(key, 'monthly');
          if (monthly.value !== '') {
            const normalized = Math.max(parseNumber(monthly.value, 0), 0);
            monthly.value = formatFixed(normalized, 2);
          }
          render();
        });
      }
      if (annual instanceof HTMLInputElement) {
        annual.addEventListener('input', () => {
          syncFixedCostPair(key, 'annual');
          render();
        });
        annual.addEventListener('change', () => {
          syncFixedCostPair(key, 'annual');
          if (annual.value !== '') {
            const normalized = Math.max(parseNumber(annual.value, 0), 0);
            annual.value = formatFixed(normalized, 2);
          }
          render();
        });
      }
    });

    function getInputs() {
      const activeMonthsRaw = parseNumberList(controls.activeMonthsInput?.value, {
        min: 0,
        max: 12,
        allowZero: false
      });
      const activeMonthsValues = activeMonthsRaw.length ? activeMonthsRaw : [10];
      if (controls.activeMonthsInput instanceof HTMLInputElement && !activeMonthsRaw.length) {
        controls.activeMonthsInput.value = String(activeMonthsValues[0]);
      }

      const weeksOffPerMonthRaw = parseNumberList(controls.weeksOffPerMonthInput?.value, {
        min: 0,
        max: 4,
        allowZero: true
      });
      const weeksOffPerMonthValues = weeksOffPerMonthRaw.length ? weeksOffPerMonthRaw : [1];
      if (controls.weeksOffPerMonthInput instanceof HTMLInputElement && !weeksOffPerMonthRaw.length) {
        controls.weeksOffPerMonthInput.value = String(weeksOffPerMonthValues[0]);
      }

      const daysOffPerWeekRaw = parseNumberList(controls.daysOffPerWeekInput?.value, {
        min: 0,
        max: BASE_WORK_DAYS_PER_WEEK,
        allowZero: true
      });
      const daysOffPerWeekValues = daysOffPerWeekRaw.length ? daysOffPerWeekRaw : [2];
      if (controls.daysOffPerWeekInput instanceof HTMLInputElement && !daysOffPerWeekRaw.length) {
        controls.daysOffPerWeekInput.value = String(daysOffPerWeekValues[0]);
      }

      const defaultActiveMonths = activeMonthsValues[0];
      const defaultWeeksOffPerMonth = weeksOffPerMonthValues[0];
      const defaultDaysOffPerWeek = daysOffPerWeekValues[0];

      const activeMonths = Number.isFinite(defaultActiveMonths) ? defaultActiveMonths : 0;
      const weeksOffPerMonth = Number.isFinite(defaultWeeksOffPerMonth) ? defaultWeeksOffPerMonth : 0;
      const daysOffPerWeek = Number.isFinite(defaultDaysOffPerWeek) ? defaultDaysOffPerWeek : 0;

      const activeMonthShare = Number.isFinite(defaultActiveMonths)
        ? Math.min(Math.max(defaultActiveMonths / 12, 0), 1)
        : 0;
      const weeksShare = Number.isFinite(defaultWeeksOffPerMonth)
        ? Math.min(Math.max((4 - defaultWeeksOffPerMonth) / 4, 0), 1)
        : 1;
      const workingWeeks = WEEKS_PER_YEAR * activeMonthShare * weeksShare;
      const workingDaysPerWeek = Math.max(BASE_WORK_DAYS_PER_WEEK - daysOffPerWeek, 0);
      const workingDaysPerYear = workingWeeks * workingDaysPerWeek;

      lastActiveMonths = Number.isFinite(defaultActiveMonths) ? defaultActiveMonths : MONTHS_PER_YEAR;
      lastWorkingWeeks = Number.isFinite(workingWeeks) ? workingWeeks : WEEKS_PER_YEAR;

      const taxRatePercent = Math.min(Math.max(parseNumber(controls.taxRate.value, 40), 0), 99.9);
      const taxRate = taxRatePercent / 100;
      if (desiredIncomeLockedAsGross) {
        synchronizeLockedDesiredIncomeNetValues(taxRate);
        synchronizeLockedAcceptableIncomeNetValues(taxRate, activeMonths);
      }
      const fixedCosts = updateFixedCostTotalDisplay();
      const variableCostPerClass = Math.max(parseNumber(controls.variableCostPerClass.value, 0), 0);
      const variableCostPerStudent = Math.max(parseNumber(controls.variableCostPerStudent.value, 0), 0);
      const variableCostPerStudentMonthly = Math.max(parseNumber(controls.variableCostPerStudentMonthly.value, 0), 0);
      const vatRate = Math.max(parseNumber(controls.vatRate.value, 21), 0) / 100;
      const classesPerWeek = parseList(controls.classesPerWeek.value);
      const studentsPerClass = parseList(controls.studentsPerClass.value);
      const hoursPerLesson = Math.max(parseNumber(controls.hoursPerLesson.value, 1, { min: 0.25, max: 12 }), 0.25);
      const bufferPercent = Math.max(parseNumber(controls.buffer.value, 15), 0);
      const buffer = bufferPercent / 100;
      const currencySymbol = controls.currencySymbol.value.trim() || '€';
      let lessonCostInclVat = null;
      if (controls.lessonCost instanceof HTMLInputElement) {
        const rawLessonCost = controls.lessonCost.value;
        if (typeof rawLessonCost === 'string' && rawLessonCost.trim() !== '') {
          const parsedLessonCost = Number(rawLessonCost);
          if (Number.isFinite(parsedLessonCost) && parsedLessonCost >= 0) {
            lessonCostInclVat = parsedLessonCost;
          }
        }
      }

      let lessonPriceMin = null;
      if (controls.lessonPriceMin instanceof HTMLInputElement) {
        const rawMin = controls.lessonPriceMin.value;
        if (typeof rawMin === 'string' && rawMin.trim() !== '') {
          const parsedMin = Number(rawMin);
          if (Number.isFinite(parsedMin) && parsedMin >= 0) {
            lessonPriceMin = parsedMin;
          }
        }
      }

      let lessonPriceMax = null;
      if (controls.lessonPriceMax instanceof HTMLInputElement) {
        const rawMax = controls.lessonPriceMax.value;
        if (typeof rawMax === 'string' && rawMax.trim() !== '') {
          const parsedMax = Number(rawMax);
          if (Number.isFinite(parsedMax) && parsedMax >= 0) {
            lessonPriceMax = parsedMax;
          }
        }
      }

      if (lessonPriceMin != null && lessonPriceMax != null && lessonPriceMin > lessonPriceMax) {
        const tempMin = lessonPriceMax;
        lessonPriceMax = lessonPriceMin;
        lessonPriceMin = tempMin;
      }

      const defaultTargetNetWeek = workingWeeks > 0 ? TARGET_NET_DEFAULT / workingWeeks : TARGET_NET_DEFAULT;
      const defaultTargetNetMonth = activeMonths > 0 ? TARGET_NET_DEFAULT / activeMonths : TARGET_NET_DEFAULT;
      const defaultTargetNetAverageWeek = TARGET_NET_DEFAULT / WEEKS_PER_YEAR;
      const defaultTargetNetAverageMonth = TARGET_NET_DEFAULT / MONTHS_PER_YEAR;

      const storedYearNet = readDesiredIncomeNet('year', null);
      const storedWeekNet = readDesiredIncomeNet('week', null);
      const storedMonthNet = readDesiredIncomeNet('month', null);
      const storedAvgWeekNet = readDesiredIncomeNet('avgWeek', null);
      const storedAvgMonthNet = readDesiredIncomeNet('avgMonth', null);

      const netYearValue = Number.isFinite(storedYearNet) ? Math.max(storedYearNet, 0) : TARGET_NET_DEFAULT;
      const netWeekValue = Number.isFinite(storedWeekNet)
        ? Math.max(storedWeekNet, 0)
        : defaultTargetNetWeek;
      const netMonthValue = Number.isFinite(storedMonthNet)
        ? Math.max(storedMonthNet, 0)
        : defaultTargetNetMonth;
      const netAvgWeekValue = Number.isFinite(storedAvgWeekNet)
        ? Math.max(storedAvgWeekNet, 0)
        : defaultTargetNetAverageWeek;
      const netAvgMonthValue = Number.isFinite(storedAvgMonthNet)
        ? Math.max(storedAvgMonthNet, 0)
        : defaultTargetNetAverageMonth;

      const hasWorkingWeeks = workingWeeks > 0;
      const hasActiveMonths = activeMonths > 0;

      let targetNet;
      if (targetNetBasis === 'week') {
        targetNet = hasWorkingWeeks ? netWeekValue * workingWeeks : netYearValue;
      } else if (targetNetBasis === 'month') {
        targetNet = hasActiveMonths ? netMonthValue * activeMonths : netYearValue;
      } else if (targetNetBasis === 'avgWeek') {
        targetNet = netAvgWeekValue * WEEKS_PER_YEAR;
      } else if (targetNetBasis === 'avgMonth') {
        targetNet = netAvgMonthValue * MONTHS_PER_YEAR;
      } else {
        targetNet = netYearValue;
      }

      targetNet = Number.isFinite(targetNet) ? Math.max(targetNet, 0) : TARGET_NET_DEFAULT;

      const targetNetPerWeek = hasWorkingWeeks ? targetNet / workingWeeks : null;
      const targetNetPerMonth = hasActiveMonths ? targetNet / activeMonths : null;
      const targetNetAveragePerWeek = targetNet / WEEKS_PER_YEAR;
      const targetNetAveragePerMonth = targetNet / MONTHS_PER_YEAR;

      const derivedNetValues = {
        year: targetNet,
        week: targetNetPerWeek,
        month: targetNetPerMonth,
        avgWeek: targetNetAveragePerWeek,
        avgMonth: targetNetAveragePerMonth
      };

      Object.entries(derivedNetValues).forEach(([key, value]) => {
        if (key === targetNetBasis) {
          if (!Number.isFinite(readDesiredIncomeNet(key, null)) && Number.isFinite(value)) {
            writeDesiredIncomeNet(key, value);
          }
          return;
        }
        if (Number.isFinite(value)) {
          writeDesiredIncomeNet(key, value);
        } else {
          writeDesiredIncomeNet(key, null);
        }
      });

      refreshDesiredIncomeDisplay(derivedNetValues, taxRate);
      refreshAcceptableIncomeDisplay(taxRate);

      controls.taxRate.value = formatFixed(taxRate * 100, 1);
      controls.fixedCosts.value = formatFixed(fixedCosts, 2);
      if (controls.variableCostPerClass instanceof HTMLInputElement) {
        controls.variableCostPerClass.value = formatFixed(variableCostPerClass, 2);
      }
      if (controls.variableCostPerStudent instanceof HTMLInputElement) {
        controls.variableCostPerStudent.value = formatFixed(variableCostPerStudent, 2);
      }
      if (controls.variableCostPerStudentMonthly instanceof HTMLInputElement) {
        controls.variableCostPerStudentMonthly.value = formatFixed(variableCostPerStudentMonthly, 2);
      }
      controls.vatRate.value = formatFixed(vatRate * 100, 1);
      if (controls.hoursPerLesson instanceof HTMLInputElement) {
        controls.hoursPerLesson.value = formatFixed(hoursPerLesson, 2);
      }
      if (controls.lessonPriceMin instanceof HTMLInputElement) {
        controls.lessonPriceMin.value =
          lessonPriceMin == null || !Number.isFinite(lessonPriceMin)
            ? ''
            : formatFixed(lessonPriceMin, 2);
      }
      if (controls.lessonPriceMax instanceof HTMLInputElement) {
        controls.lessonPriceMax.value =
          lessonPriceMax == null || !Number.isFinite(lessonPriceMax)
            ? ''
            : formatFixed(lessonPriceMax, 2);
      }
      controls.buffer.value = formatFixed(buffer * 100, 1);
      controls.currencySymbol.value = currencySymbol;
      if (controls.lessonCost instanceof HTMLInputElement) {
        if (Number.isFinite(lessonCostInclVat)) {
          controls.lessonCost.value = formatFixed(lessonCostInclVat, 2);
        } else if (typeof controls.lessonCost.value === 'string' && controls.lessonCost.value.trim() !== '') {
          controls.lessonCost.value = '';
        }
      }

      controls.workingWeeksDisplay.textContent = formatFixed(workingWeeks, 2);
      controls.workingDaysDisplay.textContent = formatFixed(workingDaysPerYear, 2);

      return {
        targetNet,
        targetNetPerWeek,
        targetNetPerMonth,
        targetNetAveragePerWeek,
        targetNetAveragePerMonth,
        taxRate,
        fixedCosts,
        variableCostPerClass,
        variableCostPerStudent,
        variableCostPerStudentMonthly,
        vatRate,
        classesPerWeek,
        studentsPerClass,
        hoursPerLesson,
        lessonCostInclVat,
        lessonPriceMin,
        lessonPriceMax,
        workingWeeks,
        buffer,
        bufferPercent,
        currencySymbol,
        activeMonths,
        activeMonthsValues,
        weeksOffPerMonth,
        weeksOffPerMonthValues,
        daysOffPerWeek,
        daysOffPerWeekValues,
        workingDaysPerWeek,
        workingDaysPerYear,
        activeMonthShare,
        weeksShare
      };
    }

    function formatCurrency(symbol, value) {
      if (!Number.isFinite(value)) {
        return `${symbol}0`;
      }
      const rounded = Math.round(value);
      const formatted = numberFormatter.format(Math.abs(rounded));
      return rounded < 0 ? `-${symbol}${formatted}` : `${symbol}${formatted}`;
    }

    function formatCurrencyDetailed(symbol, value, digits = 2) {
      if (!Number.isFinite(value)) {
        return `${symbol}0.00`;
      }
      const absolute = Math.abs(value);
      const formatted = absolute.toLocaleString(undefined, {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits
      });
      return value < 0 ? `-${symbol}${formatted}` : `${symbol}${formatted}`;
    }

    function formatCurrencyOrDash(symbol, value, digits = 2) {
      return Number.isFinite(value) ? formatCurrencyDetailed(symbol, value, digits) : '–';
    }

    function formatNumberValue(value, maximumFractionDigits = 2) {
      if (!Number.isFinite(value)) {
        return '–';
      }
      return value.toLocaleString(undefined, {
        minimumFractionDigits: 0,
        maximumFractionDigits
      });
    }

    function areValuesEqual(a, b) {
      if (!Number.isFinite(a) || !Number.isFinite(b)) {
        return false;
      }
      return Math.abs(a - b) < 1e-6;
    }

    function formatVariableValue(key, value) {
      if (!Number.isFinite(value)) {
        return '0';
      }
      const meta = VARIABLE_META[key];
      const digits = typeof meta?.fractionDigits === 'number' ? meta.fractionDigits : 2;
      if (digits === 0) {
        return value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
      }
      return formatFixed(value, digits);
    }

    function summarizeVariableValues(key, values) {
      if (!Array.isArray(values) || !values.length) {
        return 'n/a';
      }
      const unique = Array.from(new Set(values.map(value => Number(value))))
        .filter(Number.isFinite)
        .sort((a, b) => a - b);
      if (!unique.length) {
        return 'n/a';
      }
      if (unique.length === 1) {
        return formatVariableValue(key, unique[0]);
      }
      const digits = typeof VARIABLE_META[key]?.fractionDigits === 'number' ? VARIABLE_META[key].fractionDigits : 2;
      const isIntegerSequence = digits === 0;
      const isConsecutive = isIntegerSequence && unique.every((value, index) => {
        if (index === 0) {
          return true;
        }
        return Math.abs(value - unique[index - 1] - 1) < 1e-6;
      });
      if (isConsecutive) {
        return `${formatVariableValue(key, unique[0])}-${formatVariableValue(key, unique[unique.length - 1])}`;
      }
      if (unique.length <= 4) {
        return unique.map(value => formatVariableValue(key, value)).join(', ');
      }
      return `${formatVariableValue(key, unique[0])}-${formatVariableValue(key, unique[unique.length - 1])}`;
    }

    function buildVariableDefinitions(inputs) {
      const definitions = {};
      VARIABLE_ORDER.forEach(key => {
        const meta = VARIABLE_META[key] || { key, label: key, axisLabel: key, fractionDigits: 2 };
        let rawValues;
        if (key === 'studentsPerClass') {
          rawValues = Array.isArray(inputs.studentsPerClass) ? inputs.studentsPerClass : [];
        } else if (key === 'classesPerWeek') {
          rawValues = Array.isArray(inputs.classesPerWeek) ? inputs.classesPerWeek : [];
        } else if (key === 'activeMonths') {
          rawValues = Array.isArray(inputs.activeMonthsValues) ? inputs.activeMonthsValues : [];
        } else if (key === 'weeksOffPerMonth') {
          rawValues = Array.isArray(inputs.weeksOffPerMonthValues) ? inputs.weeksOffPerMonthValues : [];
        } else if (key === 'daysOffPerWeek') {
          rawValues = Array.isArray(inputs.daysOffPerWeekValues) ? inputs.daysOffPerWeekValues : [];
        } else {
          rawValues = [];
        }
        const values = Array.from(new Set(rawValues.map(value => Number(value))))
          .filter(Number.isFinite)
          .sort((a, b) => a - b);
        definitions[key] = {
          key,
          label: meta.label,
          axisLabel: meta.axisLabel,
          values,
          summary: summarizeVariableValues(key, values)
        };
      });
      return definitions;
    }

    function updateVariableSelectionState(definitions) {
      const axisCandidates = VARIABLE_ORDER.filter(key => {
        const values = definitions[key]?.values || [];
        return values.length > 1;
      });

      variableSelection.axes = variableSelection.axes.map(key => {
        if (!key) {
          return null;
        }
        if (axisCandidates.includes(key)) {
          return key;
        }
        return null;
      });

      if (variableSelection.axes[0] && variableSelection.axes[0] === variableSelection.axes[1]) {
        variableSelection.axes[1] = null;
      }

      Object.keys(variableSelection.fixedValues).forEach(key => {
        const values = definitions[key]?.values || [];
        if (!values.length || variableSelection.axes.includes(key)) {
          delete variableSelection.fixedValues[key];
        }
      });
    }

    function renderVariableControls(definitions) {
      if (!(variableControlsContainer instanceof HTMLElement)) {
        return;
      }

      const options = VARIABLE_ORDER.filter(key => definitions[key]?.values.length > 1);
      if (!options.length) {
        variableControlsContainer.hidden = true;
        variableControlsContainer.innerHTML = '';
        return;
      }

      variableControlsContainer.hidden = false;
      const fragment = document.createDocumentFragment();

      const axisPlaceholderText = 'Choose table variable';
      const buildAxisLabelText = key => {
        if (!key || !definitions[key]) {
          return axisPlaceholderText;
        }
        const definition = definitions[key];
        const summary = definition.summary;
        if (summary && summary !== 'n/a') {
          return `${definition.label} (${summary})`;
        }
        return definition.label;
      };

      variableSelection.axes.forEach((selectedKey, index) => {
        const control = document.createElement('div');
        control.className = 'variable-control control';

        const label = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.className = 'label-text';
        labelText.textContent = buildAxisLabelText(selectedKey);
        label.appendChild(labelText);

        const select = document.createElement('select');
        select.dataset.axisIndex = String(index);
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = axisPlaceholderText;
        select.appendChild(placeholder);
        options.forEach(optionKey => {
          if (index === 1 && variableSelection.axes[0] === optionKey) {
            return;
          }
          const option = document.createElement('option');
          option.value = optionKey;
          option.textContent = buildAxisLabelText(optionKey);
          select.appendChild(option);
        });
        if (selectedKey && select.querySelector(`option[value="${selectedKey}"]`)) {
          select.value = selectedKey;
        }

        const updateAxisLabel = () => {
          labelText.textContent = buildAxisLabelText(select.value || null);
        };

        select.addEventListener('change', () => {
          const nextKey = select.value || null;
          if (index === 0) {
            variableSelection.axes[0] = nextKey;
            if (nextKey && variableSelection.axes[1] === nextKey) {
              variableSelection.axes[1] = null;
            }
          } else {
            variableSelection.axes[1] = nextKey;
            if (nextKey && variableSelection.axes[0] === nextKey) {
              variableSelection.axes[0] = null;
            }
          }
          updateAxisLabel();
          render();
        });

        label.appendChild(select);
        control.appendChild(label);
        fragment.appendChild(control);
      });

      const extraKeys = options.filter(key => !variableSelection.axes.includes(key));
      extraKeys.forEach(key => {
        const definition = definitions[key];
        const control = document.createElement('div');
        control.className = 'variable-control control';
        const label = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.className = 'label-text';
        if (definition.summary && definition.summary !== 'n/a') {
          labelText.textContent = `${definition.label} (${definition.summary})`;
        } else {
          labelText.textContent = definition.label;
        }
        label.appendChild(labelText);
        const select = document.createElement('select');
        select.dataset.variableKey = key;
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Pick a value';
        select.appendChild(placeholder);
        definition.values.forEach(value => {
          const option = document.createElement('option');
          option.value = String(value);
          option.textContent = formatVariableValue(key, value);
          select.appendChild(option);
        });
        const selectedValue = variableSelection.fixedValues[key];
        if (Number.isFinite(selectedValue) && definition.values.includes(Number(selectedValue))) {
          select.value = String(selectedValue);
        }
        select.addEventListener('change', () => {
          if (select.value === '') {
            delete variableSelection.fixedValues[key];
          } else {
            const parsed = Number(select.value);
            if (Number.isFinite(parsed)) {
              variableSelection.fixedValues[key] = parsed;
            } else {
              delete variableSelection.fixedValues[key];
            }
          }
          render();
        });
        label.appendChild(select);
        control.appendChild(label);
        fragment.appendChild(control);
      });

      const resetWrapper = document.createElement('div');
      resetWrapper.className = 'variable-controls__reset';
      const resetButton = document.createElement('button');
      resetButton.type = 'button';
      resetButton.textContent = 'Reset selections';
      resetButton.addEventListener('click', () => {
        variableSelection = { axes: [null, null], fixedValues: {} };
        render();
      });
      resetWrapper.appendChild(resetButton);
      fragment.appendChild(resetWrapper);

      variableControlsContainer.innerHTML = '';
      variableControlsContainer.appendChild(fragment);
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function cloneInputs(inputs) {
      if (!inputs || typeof inputs !== 'object') {
        return null;
      }
      return {
        targetNet: inputs.targetNet,
        taxRate: inputs.taxRate,
        fixedCosts: inputs.fixedCosts,
        variableCostPerClass: inputs.variableCostPerClass,
        variableCostPerStudent: inputs.variableCostPerStudent,
        variableCostPerStudentMonthly: inputs.variableCostPerStudentMonthly,
        vatRate: inputs.vatRate,
        classesPerWeek: Array.isArray(inputs.classesPerWeek) ? [...inputs.classesPerWeek] : [],
        studentsPerClass: Array.isArray(inputs.studentsPerClass) ? [...inputs.studentsPerClass] : [],
        hoursPerLesson: inputs.hoursPerLesson,
        buffer: inputs.buffer,
        bufferPercent: inputs.bufferPercent,
        lessonCostInclVat: inputs.lessonCostInclVat,
        activeMonths: inputs.activeMonths,
        activeMonthsValues: Array.isArray(inputs.activeMonthsValues) ? [...inputs.activeMonthsValues] : [],
        weeksOffPerMonth: inputs.weeksOffPerMonth,
        weeksOffPerMonthValues: Array.isArray(inputs.weeksOffPerMonthValues)
          ? [...inputs.weeksOffPerMonthValues]
          : [],
        daysOffPerWeek: inputs.daysOffPerWeek,
        daysOffPerWeekValues: Array.isArray(inputs.daysOffPerWeekValues)
          ? [...inputs.daysOffPerWeekValues]
          : [],
        workingWeeks: inputs.workingWeeks,
        workingDaysPerWeek: inputs.workingDaysPerWeek,
        workingDaysPerYear: inputs.workingDaysPerYear,
        currencySymbol: inputs.currencySymbol,
        targetNetPerWeek: inputs.targetNetPerWeek,
        targetNetPerMonth: inputs.targetNetPerMonth,
        targetNetAveragePerWeek: inputs.targetNetAveragePerWeek,
        targetNetAveragePerMonth: inputs.targetNetAveragePerMonth,
        activeMonthShare: inputs.activeMonthShare,
        weeksShare: inputs.weeksShare
      };
    }

    function findBreakdownButton(context) {
      if (!context || !tablesContainer) {
        return null;
      }

      const { rowIndex, columnIndex, variant } = context;
      if (!Number.isFinite(rowIndex) || !Number.isFinite(columnIndex)) {
        return null;
      }
      const variantValue = variant === 'base' ? 'base' : 'buffered';

      return tablesContainer.querySelector(
        `button.price-line[data-row="${rowIndex}"][data-column="${columnIndex}"][data-variant="${variantValue}"]`
      );
    }

    function formatBreakdownCurrency(value) {
      return Number.isFinite(value) ? formatCurrency(latestCurrencySymbol, value) : '–';
    }

    function findBestPricingCombination(studentsTarget, classesPerWeekTarget, pricingData = latestPricingData) {
      if (!Array.isArray(pricingData) || !pricingData.length) {
        return null;
      }

      const tolerance = 1e-6;
      let bestMatch = null;
      let bestScore = Infinity;

      pricingData.forEach(row => {
        if (!row || !Array.isArray(row.columns)) {
          return;
        }
        row.columns.forEach(column => {
          if (!column) {
            return;
          }
          const studentsValue = Number.isFinite(column.students) ? column.students : null;
          const classesValue = Number.isFinite(column.classesPerWeek) ? column.classesPerWeek : null;
          if (studentsValue === null || classesValue === null) {
            return;
          }
          const studentDiff = Math.abs(studentsValue - studentsTarget);
          const classDiff = Math.abs(classesValue - classesPerWeekTarget);
          const score = studentDiff + classDiff / 10;
          if (score < bestScore) {
            bestScore = score;
            bestMatch = {
              row,
              column,
              studentDiff,
              classDiff
            };
          }
        });
      });

      if (!bestMatch) {
        return null;
      }

      return {
        row: bestMatch.row,
        column: bestMatch.column,
        exactStudents: bestMatch.studentDiff < tolerance,
        exactClasses: bestMatch.classDiff < tolerance
      };
    }

    function buildAccountingReport({
      studentsRequested,
      classesPerWeekRequested,
      hoursPerClassRequested,
      combination,
      inputs,
      currencySymbol,
      pricingMode,
      bufferPercent,
      bufferedMonthlyNet
    }) {
      if (!combination || !combination.row || !combination.column) {
        return null;
      }

      const { row, column, exactStudents, exactClasses } = combination;
      const breakdown = column.base && column.base.breakdown ? column.base.breakdown : null;

      if (!breakdown || !breakdown.perLesson || !breakdown.totals) {
        return null;
      }

      const totals = breakdown.totals;
      const studentsUsed = Number.isFinite(row.students) ? row.students : studentsRequested;
      const classesPerWeekUsed = Number.isFinite(column.classesPerWeek)
        ? column.classesPerWeek
        : classesPerWeekRequested;
      const workingWeeks = Number.isFinite(inputs?.workingWeeks) ? inputs.workingWeeks : 0;
      const activeMonths = Number.isFinite(inputs?.activeMonths) && inputs.activeMonths > 0
        ? inputs.activeMonths
        : MONTHS_PER_YEAR;
      const classesPerYear = Number.isFinite(column.classesPerYear)
        ? column.classesPerYear
        : classesPerWeekUsed * workingWeeks;
      const classesPerMonth = activeMonths > 0 ? classesPerYear / activeMonths : 0;
      const hoursPerClass = Number.isFinite(hoursPerClassRequested) ? hoursPerClassRequested : inputs?.hoursPerLesson;
      const weeklyHours = Number.isFinite(hoursPerClass) ? hoursPerClass * classesPerWeekUsed : null;
      const monthlyHours = Number.isFinite(hoursPerClass) ? hoursPerClass * classesPerMonth : null;

      const revenuePerLessonInclVat = Number.isFinite(totals.priceInclVatPerLesson)
        ? totals.priceInclVatPerLesson
        : totals.priceInclVatPerStudent * studentsUsed;
      const revenuePerLessonExVat = Number.isFinite(totals.priceExVatPerLesson)
        ? totals.priceExVatPerLesson
        : totals.priceExVatPerStudent * studentsUsed;
      const monthlyRevenueInclVat = revenuePerLessonInclVat * classesPerMonth;
      const monthlyRevenueExVat = revenuePerLessonExVat * classesPerMonth;
      const monthlyVat = monthlyRevenueInclVat - monthlyRevenueExVat;

      const variableCostPerClass = Number.isFinite(inputs?.variableCostPerClass)
        ? inputs.variableCostPerClass
        : 0;
      const variableCostPerStudent = Number.isFinite(inputs?.variableCostPerStudent)
        ? inputs.variableCostPerStudent
        : 0;
      const variableCostPerStudentMonthly = Number.isFinite(inputs?.variableCostPerStudentMonthly)
        ? inputs.variableCostPerStudentMonthly
        : 0;
      const monthlyVariableClass = variableCostPerClass * classesPerMonth;
      const monthlyVariableStudent = variableCostPerStudent * studentsUsed * classesPerMonth;
      const monthlyVariableStudentMonthly = variableCostPerStudentMonthly * studentsUsed;
      const monthlyVariableTotal = monthlyVariableClass + monthlyVariableStudent + monthlyVariableStudentMonthly;
      const perLessonVariableClass = variableCostPerClass;
      const perLessonVariableStudent = variableCostPerStudent * studentsUsed;
      const perLessonVariableMonthly = classesPerMonth > 0 ? monthlyVariableStudentMonthly / classesPerMonth : 0;

      const fixedCosts = Number.isFinite(inputs?.fixedCosts) ? inputs.fixedCosts : 0;
      const monthlyFixedCosts = activeMonths > 0 ? fixedCosts / activeMonths : 0;
      const perLessonFixed = classesPerMonth > 0 ? monthlyFixedCosts / classesPerMonth : 0;

      const taxRate = Number.isFinite(inputs?.taxRate) ? inputs.taxRate : 0;
      const profitBeforeTax = monthlyRevenueExVat - monthlyVariableTotal - monthlyFixedCosts;
      const monthlyIncomeTax = profitBeforeTax > 0 ? profitBeforeTax * taxRate : 0;
      const perLessonIncomeTax = classesPerMonth > 0 ? monthlyIncomeTax / classesPerMonth : 0;
      const monthlyNetIncome = profitBeforeTax - monthlyIncomeTax;
      const perLessonNetIncome = classesPerMonth > 0 ? monthlyNetIncome / classesPerMonth : 0;

      const perLessonVat = classesPerMonth > 0 ? monthlyVat / classesPerMonth : 0;
      const perLessonOutgoings =
        perLessonVat + perLessonVariableClass + perLessonVariableStudent + perLessonVariableMonthly + perLessonFixed + perLessonIncomeTax;
      const monthlyOutgoings =
        monthlyVat + monthlyVariableClass + monthlyVariableStudent + monthlyVariableStudentMonthly + monthlyFixedCosts + monthlyIncomeTax;

      const netMargin = monthlyRevenueExVat > 0 ? (monthlyNetIncome / monthlyRevenueExVat) * 100 : null;
      const effectiveHourlyNet = Number.isFinite(monthlyHours) && monthlyHours > 0
        ? monthlyNetIncome / monthlyHours
        : null;
      const effectiveHourlyGross = Number.isFinite(monthlyHours) && monthlyHours > 0
        ? monthlyRevenueInclVat / monthlyHours
        : null;
      const approxWeeksPerActiveMonth = activeMonths > 0 && Number.isFinite(workingWeeks)
        ? workingWeeks / activeMonths
        : 0;

      const currency = typeof currencySymbol === 'string' && currencySymbol.trim() !== ''
        ? currencySymbol
        : '€';
      const now = new Date();
      const generatedDisplay = now.toLocaleString(undefined, {
        dateStyle: 'long',
        timeStyle: 'short'
      });

      const notes = [];
      if (!exactStudents && Number.isFinite(studentsRequested)) {
        notes.push(
          `Requested ${formatNumberValue(studentsRequested, 2)} students; closest available combination uses ${formatNumberValue(studentsUsed, 2)}.`
        );
      }
      if (!exactClasses && Number.isFinite(classesPerWeekRequested)) {
        notes.push(
          `Requested ${formatNumberValue(classesPerWeekRequested, 2)} classes per week; closest available combination uses ${formatNumberValue(classesPerWeekUsed, 2)}.`
        );
      }

      if (pricingMode === PRICING_MODE_TARGET) {
        if (Number.isFinite(bufferPercent) && bufferPercent > 0 && Number.isFinite(bufferedMonthlyNet)) {
          notes.push(
            `Buffered shortfall scenario (${formatFixed(bufferPercent, 1)}% attendance loss) projects ${formatCurrencyOrDash(currency, bufferedMonthlyNet)} net per month.`
          );
        } else {
          notes.push('Report reflects the base pricing scenario that meets your net income target.');
        }
      } else {
        notes.push('Report uses the manual lesson price you entered.');
      }

      const notesMarkup = notes.length
        ? `<section class="report-section">
            <h2>Notes</h2>
            <ul class="report-list">${notes.map(note => `<li>${escapeHtml(note)}</li>`).join('')}</ul>
          </section>`
        : '';

      const summaryItems = [
        { label: 'Students per class', value: formatNumberValue(studentsUsed, 2) },
        { label: 'Classes per week', value: formatNumberValue(classesPerWeekUsed, 2) },
        { label: 'Classes per active month', value: formatNumberValue(classesPerMonth, 2) },
        { label: 'Hours per class', value: formatNumberValue(hoursPerClass, 2) },
        { label: 'Teaching hours / week', value: formatNumberValue(weeklyHours, 2) },
        { label: 'Teaching hours / month', value: formatNumberValue(monthlyHours, 2) },
        { label: 'Active months / year', value: formatNumberValue(activeMonths, 2) },
        { label: 'Working weeks / active month', value: formatNumberValue(approxWeeksPerActiveMonth, 2) },
        { label: 'VAT rate', value: `${formatFixed((inputs?.vatRate ?? 0) * 100, 1)}%` },
        { label: 'Income tax rate', value: `${formatFixed(taxRate * 100, 1)}%` }
      ];

      const summaryMarkup = summaryItems
        .map(item => `
          <div class="summary-item">
            <span class="summary-label">${escapeHtml(item.label)}</span>
            <span class="summary-value">${escapeHtml(item.value)}</span>
          </div>
        `)
        .join('');

      const currencyEscaped = escapeHtml(currency);

      const html = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Monthly accounting breakdown</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
        background: #f4f6fc;
        color: #111827;
        padding: 32px 16px;
      }
      .report {
        max-width: 960px;
        margin: 0 auto;
        background: #ffffff;
        border-radius: 20px;
        box-shadow: 0 30px 55px rgba(15, 23, 42, 0.12);
        padding: clamp(24px, 4vw, 40px);
      }
      .report-header {
        display: flex;
        justify-content: space-between;
        gap: 24px;
        flex-wrap: wrap;
      }
      .report-header h1 {
        margin: 0 0 8px;
        font-size: clamp(1.6rem, 2.8vw, 2.3rem);
      }
      .report-subtitle {
        margin: 0;
        color: #4b5563;
        font-size: 1rem;
      }
      .report-meta {
        min-width: 220px;
        background: #f1f5f9;
        border-radius: 16px;
        padding: 16px 18px;
        font-size: 0.95rem;
        color: #1f2937;
      }
      .report-meta p {
        margin: 0 0 6px;
      }
      .report-meta span {
        display: block;
        color: #64748b;
        font-size: 0.85rem;
      }
      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 18px;
        margin-top: 20px;
      }
      .summary-item {
        background: #f8fafc;
        border-radius: 16px;
        padding: 14px 16px;
      }
      .summary-label {
        display: block;
        color: #6b7280;
        font-size: 0.85rem;
      }
      .summary-value {
        display: block;
        font-weight: 600;
        margin-top: 4px;
        font-size: 1.05rem;
      }
      .report-section {
        margin-top: 32px;
      }
      .report-section h2 {
        margin: 0 0 12px;
        font-size: 1.3rem;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        background: #ffffff;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px #e2e8f0;
      }
      thead {
        background: #edf2ff;
      }
      th,
      td {
        padding: 12px 16px;
        border-bottom: 1px solid #e2e8f0;
        font-size: 0.97rem;
      }
      th {
        text-align: left;
        font-weight: 600;
        color: #334155;
      }
      td.numeric {
        text-align: right;
        font-variant-numeric: tabular-nums;
        color: #111827;
      }
      tbody tr:last-child td,
      tbody tr:last-child th {
        border-bottom: none;
      }
      .totals-row th,
      .totals-row td {
        font-weight: 700;
        background: #f8fafc;
      }
      .report-list {
        margin: 12px 0 0;
        padding-left: 20px;
        color: #1f2937;
      }
      .report-footer {
        margin-top: 36px;
        font-size: 0.9rem;
        color: #64748b;
        text-align: right;
      }
      @media (max-width: 640px) {
        .report-meta {
          width: 100%;
        }
        table {
          font-size: 0.92rem;
        }
        th,
        td {
          padding: 10px 12px;
        }
      }
    </style>
  </head>
  <body>
    <main class="report">
      <header class="report-header">
        <div>
          <h1>Monthly accounting breakdown</h1>
          <p class="report-subtitle">${escapeHtml(
            `${formatNumberValue(studentsUsed, 2)} students · ${formatNumberValue(classesPerWeekUsed, 2)} classes per week`
          )}</p>
        </div>
        <div class="report-meta">
          <p><span>Generated</span>${escapeHtml(generatedDisplay)}</p>
          <p><span>Pricing mode</span>${escapeHtml(
            pricingMode === PRICING_MODE_TARGET ? 'Target net income (base price)' : 'Manual price per student'
          )}</p>
          <p><span>Currency</span>${currencyEscaped}</p>
        </div>
      </header>
      <section class="report-section">
        <h2>Scenario summary</h2>
        <div class="summary-grid">${summaryMarkup}</div>
      </section>
      <section class="report-section">
        <h2>Incomings</h2>
        <table>
          <thead>
            <tr>
              <th scope="col">Line item</th>
              <th scope="col" class="numeric">Per lesson</th>
              <th scope="col" class="numeric">Monthly total</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">Tuition revenue (incl. VAT)</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, revenuePerLessonInclVat))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyRevenueInclVat))}</td>
            </tr>
            <tr>
              <th scope="row">Tuition revenue (excl. VAT)</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, revenuePerLessonExVat))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyRevenueExVat))}</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section class="report-section">
        <h2>Outgoings</h2>
        <table>
          <thead>
            <tr>
              <th scope="col">Line item</th>
              <th scope="col" class="numeric">Per lesson</th>
              <th scope="col" class="numeric">Monthly total</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">VAT payable</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonVat))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyVat))}</td>
            </tr>
            <tr>
              <th scope="row">Variable costs – per class</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonVariableClass))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyVariableClass))}</td>
            </tr>
            <tr>
              <th scope="row">Variable costs – per student per class</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonVariableStudent))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyVariableStudent))}</td>
            </tr>
            <tr>
              <th scope="row">Variable costs – per student per month</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonVariableMonthly))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyVariableStudentMonthly))}</td>
            </tr>
            <tr>
              <th scope="row">Fixed cost allocation</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonFixed))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyFixedCosts))}</td>
            </tr>
            <tr>
              <th scope="row">Income tax provision</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonIncomeTax))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyIncomeTax))}</td>
            </tr>
            <tr class="totals-row">
              <th scope="row">Total outgoings</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonOutgoings))}</td>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyOutgoings))}</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section class="report-section">
        <h2>Net position</h2>
        <table>
          <thead>
            <tr>
              <th scope="col">Metric</th>
              <th scope="col" class="numeric">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">Monthly profit before tax</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, profitBeforeTax))}</td>
            </tr>
            <tr>
              <th scope="row">Monthly net income</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, monthlyNetIncome))}</td>
            </tr>
            <tr>
              <th scope="row">Net margin (on ex-VAT revenue)</th>
              <td class="numeric">${Number.isFinite(netMargin) ? escapeHtml(`${formatFixed(netMargin, 1)}%`) : '–'}</td>
            </tr>
            <tr>
              <th scope="row">Gross hourly revenue</th>
              <td class="numeric">${Number.isFinite(effectiveHourlyGross) ? escapeHtml(formatCurrencyDetailed(currency, effectiveHourlyGross)) : '–'}</td>
            </tr>
            <tr>
              <th scope="row">Net hourly pay</th>
              <td class="numeric">${Number.isFinite(effectiveHourlyNet) ? escapeHtml(formatCurrencyDetailed(currency, effectiveHourlyNet)) : '–'}</td>
            </tr>
            <tr>
              <th scope="row">Net income per lesson</th>
              <td class="numeric">${escapeHtml(formatCurrencyOrDash(currency, perLessonNetIncome))}</td>
            </tr>
          </tbody>
        </table>
      </section>
      ${notesMarkup}
      <p class="report-footer">Generated with the Income Calculator.</p>
    </main>
  </body>
</html>`;

      return html;
    }

    function populateBreakdownDialog(context) {
      if (
        !context ||
        !Array.isArray(latestPricingData) ||
        !breakdownDialog ||
        !breakdownSummary
      ) {
        return false;
      }

      const isTargetMode = latestPricingMode === PRICING_MODE_TARGET;
      const isLessonMode = latestPricingMode === PRICING_MODE_LESSON;

      if (!isTargetMode && !isLessonMode) {
        return false;
      }

      const { rowIndex, columnIndex, variant } = context;
      const row = latestPricingData[rowIndex];
      if (!row || !Array.isArray(row.columns)) {
        return false;
      }

      const column = row.columns[columnIndex];
      if (!column) {
        return false;
      }

      const pricingVariant = variant === 'base' ? column.base : column.buffered;
      if (!pricingVariant || !pricingVariant.breakdown) {
        return false;
      }

      const breakdown = pricingVariant.breakdown;
      const perStudentInclVat = formatCurrencyOrDash(latestCurrencySymbol, pricingVariant.price?.inclVat, 2);
      const perStudentExVat = formatCurrencyOrDash(latestCurrencySymbol, pricingVariant.price?.exVat, 2);
      const perLessonInclVat = formatCurrencyOrDash(latestCurrencySymbol, breakdown.totals.priceInclVatPerLesson, 2);
      const perLessonExVat = formatCurrencyOrDash(latestCurrencySymbol, breakdown.totals.priceExVatPerLesson, 2);

      const studentsDisplay = Number.isFinite(column.students)
        ? numberFormatter.format(column.students)
        : '–';
      const classesPerWeekValue = column.classesPerWeek;
      const classesPerWeekDisplay = Number.isFinite(classesPerWeekValue)
        ? (Number.isInteger(classesPerWeekValue)
            ? numberFormatter.format(classesPerWeekValue)
            : formatFixed(classesPerWeekValue, 2))
        : '–';
      const classesPerYearDisplay = Number.isFinite(column.classesPerYear)
        ? numberFormatter.format(Math.round(column.classesPerYear))
        : '–';

      let variantLabel;
      if (isLessonMode) {
        variantLabel = variant === 'base'
          ? 'Full attendance at set lesson price'
          : `Attendance shortfall (${formatFixed(latestBufferPercent, 1)}% less revenue)`;
      } else {
        variantLabel = variant === 'base'
          ? 'Base price (no buffer)'
          : `Buffered price (+${formatFixed(latestBufferPercent, 1)}% extra safety margin)`;
      }

      if (breakdownVariant) {
        breakdownVariant.textContent = variantLabel;
      }

      if (breakdownPrice) {
        breakdownPrice.textContent = `${perStudentInclVat} per student (${perStudentExVat} ex VAT)`;
      }

      if (breakdownMeta) {
        breakdownMeta.textContent = `${studentsDisplay} students · ${classesPerWeekDisplay} classes/week (≈ ${classesPerYearDisplay} / yr)`;
      }

      if (breakdownTotal) {
        breakdownTotal.textContent = `Total collected per lesson: ${perLessonInclVat} (${perLessonExVat} ex VAT)`;
      }

      const tableRows = [
        { key: 'vat', label: 'VAT remitted' },
        { key: 'variableCosts', label: 'Variable costs' },
        { key: 'fixedCostAllocation', label: 'Fixed cost allocation' },
        { key: 'incomeTax', label: 'Income tax' },
        { key: 'netIncome', label: 'Net income after tax' }
      ];

      if (breakdownTableBody) {
        const rowsMarkup = tableRows
          .map(item => {
            const perStudentValue = breakdown.perStudent[item.key];
            const perLessonValue = breakdown.perLesson[item.key];
            return `
              <tr>
                <th scope="row">${item.label}</th>
                <td>${formatBreakdownCurrency(perStudentValue)}</td>
                <td>${formatBreakdownCurrency(perLessonValue)}</td>
              </tr>
            `;
          })
          .join('');
        breakdownTableBody.innerHTML = rowsMarkup;
      }

      const legendItems = [
        { key: 'vat', label: 'VAT remitted', value: breakdown.perLesson.vat, color: 'var(--breakdown-color-vat)' },
        { key: 'variableCosts', label: 'Variable costs', value: breakdown.perLesson.variableCosts, color: 'var(--breakdown-color-variable)' },
        { key: 'fixedCostAllocation', label: 'Fixed cost allocation', value: breakdown.perLesson.fixedCostAllocation, color: 'var(--breakdown-color-fixed)' },
        { key: 'incomeTax', label: 'Income tax', value: breakdown.perLesson.incomeTax, color: 'var(--breakdown-color-tax)' },
        { key: 'netIncome', label: 'Net income after tax', value: breakdown.perLesson.netIncome, color: 'var(--breakdown-color-net)' }
      ];

      if (breakdownLegend) {
        const legendMarkup = legendItems
          .map(item => `
            <li class="lesson-breakdown-dialog__legend-item">
              <span class="lesson-breakdown-dialog__legend-swatch" style="--swatch-color:${item.color};"></span>
              <span class="lesson-breakdown-dialog__legend-label">${item.label}</span>
              <span class="lesson-breakdown-dialog__legend-value">${formatBreakdownCurrency(item.value)}</span>
            </li>
          `)
          .join('');
        breakdownLegend.innerHTML = legendMarkup;
      }

      if (breakdownChartGraphic) {
        const positiveSegments = legendItems.map(item => Math.max(item.value, 0));
        const total = positiveSegments.reduce((sum, value) => sum + value, 0);

        if (total > 0) {
          let currentAngle = 0;
          const segments = legendItems
            .map((item, index) => {
              const value = positiveSegments[index];
              if (value <= 0) {
                return null;
              }
              const start = currentAngle;
              const end = start + (value / total) * 360;
              currentAngle = end;
              return `${item.color} ${start}deg ${end}deg`;
            })
            .filter(Boolean);

          breakdownChartGraphic.style.background = segments.length
            ? `conic-gradient(${segments.join(', ')})`
            : 'radial-gradient(circle at 50% 50%, var(--price-line-bg), var(--row-header-bg))';
        } else {
          breakdownChartGraphic.style.background = 'radial-gradient(circle at 50% 50%, var(--price-line-bg), var(--row-header-bg))';
        }

      }

      return true;
    }

    function openBreakdownDialog(context, triggerElement) {
      if (!breakdownDialog) {
        return;
      }

      const normalizedContext = {
        rowIndex: Number(context?.rowIndex),
        columnIndex: Number(context?.columnIndex),
        variant: context?.variant === 'base' ? 'base' : 'buffered'
      };

      if (!populateBreakdownDialog(normalizedContext)) {
        return;
      }

      activeBreakdownContext = normalizedContext;
      breakdownTriggerElement = triggerElement instanceof HTMLElement ? triggerElement : null;
      breakdownDialog.hidden = false;
      breakdownDialog.scrollTop = 0;
      setBodyScrollLock('breakdown', true);

      window.requestAnimationFrame(() => {
        const focusable = getFocusableElements(breakdownDialog);
        if (focusable.length) {
          focusable[0].focus();
        } else if (breakdownClose) {
          breakdownClose.focus();
        }
      });

      document.addEventListener('keydown', handleBreakdownKeydown);
    }

    function closeBreakdownDialog() {
      if (!breakdownDialog || breakdownDialog.hidden) {
        return;
      }

      breakdownDialog.hidden = true;
      setBodyScrollLock('breakdown', false);
      document.removeEventListener('keydown', handleBreakdownKeydown);

      const trigger = breakdownTriggerElement;
      breakdownTriggerElement = null;
      activeBreakdownContext = null;

      if (trigger instanceof HTMLElement && trigger.isConnected && typeof trigger.focus === 'function') {
        trigger.focus();
      }
    }

    function handleBreakdownKeydown(event) {
      if (!breakdownDialog || breakdownDialog.hidden) {
        return;
      }

      if (event.key === 'Escape') {
        event.preventDefault();
        closeBreakdownDialog();
        return;
      }

      if (event.key === 'Tab') {
        const focusable = getFocusableElements(breakdownDialog);
        if (!focusable.length) {
          event.preventDefault();
          return;
        }

        const first = focusable[0];
        const last = focusable[focusable.length - 1];

        if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        } else if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        }
      }
    }

    function refreshBreakdownDialog() {
      if (!breakdownDialog || breakdownDialog.hidden || !activeBreakdownContext) {
        return false;
      }

      const refreshed = populateBreakdownDialog(activeBreakdownContext);
      if (refreshed) {
        const updatedTrigger = findBreakdownButton(activeBreakdownContext);
        if (updatedTrigger) {
          breakdownTriggerElement = updatedTrigger;
        }
      }

      return refreshed;
    }

    function computeNetIncomeFromRevenue(revenue, fixedCosts, effectiveTaxRate, variableCosts = 0) {
      if (!Number.isFinite(revenue)) {
        return null;
      }
      const normalizedVariableCosts = Number.isFinite(variableCosts) ? variableCosts : 0;
      const profitBeforeTax = revenue - fixedCosts - normalizedVariableCosts;
      return profitBeforeTax * (1 - effectiveTaxRate);
    }

    function shouldHighlightIncome({ monthlyNet, annualNet }, options = {}) {
      const {
        acceptableIncome = null,
        displayMode = 'net',
        taxRate = 0,
        activeMonths = MONTHS_PER_YEAR
      } = options;

      if (!acceptableIncome || typeof acceptableIncome !== 'object') {
        return false;
      }

      const { basis, minAnnualNet, maxAnnualNet } = acceptableIncome;
      const hasMin = Number.isFinite(minAnnualNet);
      const hasMax = Number.isFinite(maxAnnualNet);

      if (!basis || (!hasMin && !hasMax)) {
        return false;
      }

      const normalizedTaxRate = Math.min(Math.max(taxRate, 0), 0.9999);
      const denominator = Math.max(1 - normalizedTaxRate, 0.0001);
      const monthsForRange = activeMonths > 0 ? activeMonths : MONTHS_PER_YEAR;

      const convertNetToDisplay = value => {
        if (!Number.isFinite(value)) {
          return null;
        }
        return displayMode === 'gross' ? value / denominator : value;
      };

      if (basis === 'annual') {
        if (!Number.isFinite(annualNet)) {
          return false;
        }
        const valueDisplay = convertNetToDisplay(annualNet);
        const minDisplay = hasMin ? convertNetToDisplay(minAnnualNet) : null;
        const maxDisplay = hasMax ? convertNetToDisplay(maxAnnualNet) : null;
        if (!Number.isFinite(valueDisplay)) {
          return false;
        }
        if (Number.isFinite(minDisplay) && valueDisplay < minDisplay) {
          return false;
        }
        if (Number.isFinite(maxDisplay) && valueDisplay > maxDisplay) {
          return false;
        }
        return true;
      }

      if (!Number.isFinite(monthlyNet)) {
        return false;
      }
      const valueDisplay = convertNetToDisplay(monthlyNet);
      const minDisplay = hasMin ? convertNetToDisplay(minAnnualNet / monthsForRange) : null;
      const maxDisplay = hasMax ? convertNetToDisplay(maxAnnualNet / monthsForRange) : null;
      if (!Number.isFinite(valueDisplay)) {
        return false;
      }
      if (Number.isFinite(minDisplay) && valueDisplay < minDisplay) {
        return false;
      }
      if (Number.isFinite(maxDisplay) && valueDisplay > maxDisplay) {
        return false;
      }
      return true;
    }

    function buildPricingTable(data, symbol, bufferPercent, options = {}) {
      if (!Array.isArray(data) || !data.length) {
        return `<div class="card"><p class="status-message">No valid combinations available.</p></div>`;
      }

      const {
        mode = PRICING_MODE_TARGET,
        showBasePrices: showBase = false,
        minLessonPrice = null,
        maxLessonPrice = null,
        acceptableIncome: acceptableIncomeRange = null,
        desiredIncomeDisplayMode: incomeDisplayMode = 'net',
        taxRate: incomeTaxRate = 0,
        activeMonths: incomeActiveMonths = MONTHS_PER_YEAR,
        hoursPerLesson: lessonHours = 1,
        axisMeta = null,
        axisInfo = null,
        axisKeys = null
      } = options;

      const formattedBuffer = formatFixed(bufferPercent, 1);
      const showBasePricesActive = mode === PRICING_MODE_TARGET ? showBase : true;
      const cardClasses = ['card', 'pricing-card'];
      if (showBasePricesActive) {
        cardClasses.push('show-base-prices');
      }

      const hasPreferredRange = Number.isFinite(minLessonPrice) || Number.isFinite(maxLessonPrice);
      const normalizedLessonHours = Number.isFinite(lessonHours) && lessonHours > 0 ? lessonHours : null;
      const rowAxisLabel = axisMeta?.rows?.axisLabel || axisMeta?.rows?.label || 'Rows';
      const columnAxisLabel = axisMeta?.columns?.axisLabel || axisMeta?.columns?.label || 'Columns';
      const columnDescriptors = Array.isArray(axisInfo?.columns?.values) && axisInfo.columns.values.length
        ? axisInfo.columns.values
        : data[0].columns.map((_, index) => ({ value: index + 1, label: String(index + 1) }));
      const columnSamples = columnDescriptors.map((_, columnIndex) => {
        for (let rowIndex = 0; rowIndex < data.length; rowIndex += 1) {
          const candidate = data[rowIndex]?.columns?.[columnIndex];
          if (candidate) {
            return candidate;
          }
        }
        return null;
      });

      const toggleMarkup = mode === PRICING_MODE_TARGET
        ? `<div class="price-toggle-row">
            <button type="button" class="price-reveal-toggle secondary" aria-expanded="${showBasePricesActive}">
              ${showBasePricesActive ? 'Hide base results' : 'Show base results'}
            </button>
          </div>`
        : '';

      const columnHeaders = columnDescriptors
        .map((descriptor, columnIndex) => {
          const label = descriptor?.label != null ? String(descriptor.label) : String(descriptor?.value ?? '');
          const subLabel = axisKeys?.columns === 'classesPerWeek'
            ? buildClassesPerYearLabel(columnSamples[columnIndex])
            : '';
          return `<th scope="col">${escapeHtml(label)}${subLabel}</th>`;
        })
        .join('');

      const rowsHtml = data
        .map((row, rowIndex) => {
          const rowLabel = row?.label != null
            ? String(row.label)
            : formatAxisValue(axisKeys?.rows || axisInfo?.rows?.key || null, row?.value);
          const cells = row.columns
            .map((columnResult, columnIndex) => renderCell(columnResult, rowIndex, columnIndex))
            .join('');
          return `<tr><th scope="row">${escapeHtml(rowLabel)}</th>${cells}</tr>`;
        })
        .join('');

      const caption = axisMeta
        ? `<caption>${escapeHtml(rowAxisLabel)} × ${escapeHtml(columnAxisLabel)} income table</caption>`
        : '<caption>Income table</caption>';

      return `
        <div class="${cardClasses.join(' ')}">
          ${toggleMarkup}
          <div class="card-scroll">
            <table>
              ${caption}
              <thead>
                <tr>
                  <th scope="col">${escapeHtml(rowAxisLabel)}</th>
                  ${columnHeaders}
                </tr>
              </thead>
              <tbody>
                ${rowsHtml}
              </tbody>
            </table>
          </div>
        </div>
      `;

      function formatAxisValue(key, value) {
        if (Number.isFinite(value) && key) {
          return formatVariableValue(key, value);
        }
        if (Number.isFinite(value)) {
          return value.toString();
        }
        return value == null ? '–' : String(value);
      }

      function buildClassesPerYearLabel(sample) {
        if (!sample) {
          return '';
        }
        const classesPerYear = Number.isFinite(sample.classesPerYear)
          ? Math.round(sample.classesPerYear)
          : null;
        if (!Number.isFinite(classesPerYear)) {
          return '';
        }
        return `<span class="sub-label">≈ ${numberFormatter.format(classesPerYear)} / yr</span>`;
      }

      function formatIncomeValue(value) {
        return Number.isFinite(value) ? formatCurrency(symbol, value) : '–';
      }

      function computeHourlyIncome(variant) {
        if (!variant || !normalizedLessonHours) {
          return { net: null, gross: null };
        }
        const netPerLesson = variant?.breakdown?.perLesson?.netIncome;
        if (!Number.isFinite(netPerLesson)) {
          return { net: null, gross: null };
        }
        const grossPerLesson = convertNetToGross(netPerLesson, incomeTaxRate);
        const netHourly = netPerLesson / normalizedLessonHours;
        const grossHourly = Number.isFinite(grossPerLesson)
          ? grossPerLesson / normalizedLessonHours
          : null;
        return {
          net: Number.isFinite(netHourly) ? netHourly : null,
          gross: Number.isFinite(grossHourly) ? grossHourly : null
        };
      }

      function renderIncomeGrid(variant) {
        const entries = [
          { label: 'Monthly net', value: variant?.net?.monthly },
          { label: 'Monthly gross', value: variant?.gross?.monthly },
          { label: 'Annual net', value: variant?.net?.annual },
          { label: 'Annual gross', value: variant?.gross?.annual }
        ];
        return `
          <div class="income-grid">
            ${entries
              .map(entry => `
                <div class="income-grid__item">
                  <span class="income-label">${escapeHtml(entry.label)}</span>
                  <span class="income-value">${formatIncomeValue(entry.value)}</span>
                </div>
              `)
              .join('')}
          </div>
        `;
      }

      function renderPriceLines(variant) {
        if (mode !== PRICING_MODE_TARGET) {
          return '';
        }
        return `
          <span class="price-secondary">Lesson price incl VAT ${formatCurrencyOrDash(symbol, variant?.price?.inclVat, 2)}</span>
          <span class="price-secondary">Lesson price ex VAT ${formatCurrencyOrDash(symbol, variant?.price?.exVat, 2)}</span>
        `;
      }

      function renderHourlyLine(hourly) {
        if (!Number.isFinite(hourly.net) && !Number.isFinite(hourly.gross)) {
          return '';
        }
        return `<span class="price-tertiary">Hourly net ${formatCurrencyOrDash(symbol, hourly.net, 2)} · Hourly gross ${formatCurrencyOrDash(symbol, hourly.gross, 2)}</span>`;
      }

      function isPriceOutOfRange(value) {
        if (!hasPreferredRange || !Number.isFinite(value)) {
          return false;
        }
        if (Number.isFinite(minLessonPrice) && value < minLessonPrice) {
          return true;
        }
        if (Number.isFinite(maxLessonPrice) && value > maxLessonPrice) {
          return true;
        }
        return false;
      }

      function renderCell(result, rowIndex, columnIndex) {
        if (!result) {
          return '<td class="price-cell-empty">–</td>';
        }

        const baseVariant = result.base || null;
        const bufferedVariant = result.buffered || null;

        const highlightBase = shouldHighlightIncome(
          { monthlyNet: baseVariant?.net?.monthly, annualNet: baseVariant?.net?.annual },
          {
            acceptableIncome: acceptableIncomeRange,
            displayMode: incomeDisplayMode,
            taxRate: incomeTaxRate,
            activeMonths: incomeActiveMonths
          }
        );
        const highlightBuffered = shouldHighlightIncome(
          { monthlyNet: bufferedVariant?.net?.monthly, annualNet: bufferedVariant?.net?.annual },
          {
            acceptableIncome: acceptableIncomeRange,
            displayMode: incomeDisplayMode,
            taxRate: incomeTaxRate,
            activeMonths: incomeActiveMonths
          }
        );

        const baseOutOfRange = mode === PRICING_MODE_TARGET && isPriceOutOfRange(baseVariant?.price?.inclVat);
        const bufferedOutOfRange = mode === PRICING_MODE_TARGET && isPriceOutOfRange(bufferedVariant?.price?.inclVat);

        const baseClasses = ['price-line', 'base'];
        if (baseOutOfRange) {
          baseClasses.push('price-line--out-of-range');
        }
        if (highlightBase) {
          baseClasses.push('price-line--acceptable');
        }

        const bufferedClasses = ['price-line', 'buffered'];
        if (bufferedOutOfRange) {
          bufferedClasses.push('price-line--out-of-range');
        }
        if (highlightBuffered) {
          bufferedClasses.push('price-line--acceptable');
        }

        const bufferedMarkup = renderVariantButton({
          variant: bufferedVariant,
          label: `Buffered +${formattedBuffer}%`,
          classes: bufferedClasses,
          rowIndex,
          columnIndex,
          variantKey: 'buffered'
        });

        const baseMarkup = renderVariantButton({
          variant: baseVariant,
          label: 'Base (no buffer)',
          classes: baseClasses,
          rowIndex,
          columnIndex,
          variantKey: 'base'
        });

        return `
          <td>
            <div class="price-pair">
              ${bufferedMarkup}
              ${baseMarkup}
            </div>
          </td>
        `;
      }

      function renderVariantButton({ variant, label, classes, rowIndex, columnIndex, variantKey }) {
        if (!variant) {
          return `<div class="${classes.join(' ')}">${escapeHtml(label)}</div>`;
        }

        const hourly = computeHourlyIncome(variant);
        const incomeGrid = renderIncomeGrid(variant);
        const priceLines = renderPriceLines(variant);
        const hourlyLine = renderHourlyLine(hourly);

        const hiddenAttr = mode === PRICING_MODE_TARGET && !showBasePricesActive && variantKey === 'base'
          ? ' aria-hidden="true"'
          : '';

        return `
          <button
            type="button"
            class="${classes.join(' ')}"
            data-row="${rowIndex}"
            data-column="${columnIndex}"
            data-variant="${variantKey}"${hiddenAttr}
          >
            <span class="price-label">${escapeHtml(label)}</span>
            ${incomeGrid}
            ${priceLines}
            ${hourlyLine}
          </button>
        `;
      }
    }

    function buildActiveTargetsTable({
      currencySymbol,
      revenueNeeded,
      workingDaysPerYear,
      workingWeeks,
      activeMonths
    }) {
      if (!Number.isFinite(revenueNeeded) || revenueNeeded <= 0) {
        return '';
      }

      const targets = [
        {
          label: 'Active day',
          basis: workingDaysPerYear,
          suffix: 'active days / year'
        },
        {
          label: 'Active week',
          basis: workingWeeks,
          suffix: 'active weeks / year'
        },
        {
          label: 'Active month',
          basis: activeMonths,
          suffix: 'active months / year'
        }
      ];

      const rows = targets
        .map(target => {
          const hasBasis = Number.isFinite(target.basis) && target.basis > 0;
          const amount = hasBasis ? revenueNeeded / target.basis : null;
          const amountDisplay = hasBasis && Number.isFinite(amount)
            ? formatCurrency(currencySymbol, amount)
            : '–';
          const basisDisplay = hasBasis
            ? `Based on ≈ ${formatFixed(target.basis, 2)} ${target.suffix}`
            : '–';

          return `
            <tr>
              <th scope="row">${target.label}</th>
              <td>${amountDisplay}</td>
              <td>${basisDisplay}</td>
            </tr>
          `;
        })
        .join('');

      return `
        <div class="card">
          <div class="card-scroll">
            <table>
              <caption>
                Gross Revenue Needed To Achieve Net Income Targets
                <span
                  class="info-icon"
                  tabindex="0"
                  role="button"
                  aria-expanded="false"
                  aria-label="“Active” periods exclude the time you planned off (months, weeks, and days away from teaching)."
                  data-tooltip="“Active” periods exclude the time you planned off (months, weeks, and days away from teaching)."
                >ℹ️</span>
              </caption>
              <thead>
                <tr>
                  <th scope="col">Target</th>
                  <th scope="col">Revenue needed</th>
                  <th scope="col">Basis</th>
                </tr>
              </thead>
              <tbody>
                ${rows}
              </tbody>
            </table>
          </div>
        </div>
      `;
    }

    function computeTables(inputs, selection, variableDefinitions) {
      const {
        targetNet,
        taxRate,
        fixedCosts,
        variableCostPerClass,
        variableCostPerStudent,
        variableCostPerStudentMonthly,
        vatRate,
        classesPerWeek,
        studentsPerClass,
        hoursPerLesson,
        buffer,
        bufferPercent,
        lessonCostInclVat,
        activeMonths,
        activeMonthsValues,
        weeksOffPerMonthValues,
        daysOffPerWeekValues,
        currencySymbol
      } = inputs;

      latestResults = [];

      const manualMode = Number.isFinite(lessonCostInclVat);
      const mode = manualMode ? PRICING_MODE_LESSON : PRICING_MODE_TARGET;
      const effectiveTaxRate = Math.min(taxRate, 0.99);
      const axisKeys = Array.isArray(selection?.axes) ? selection.axes : [null, null];
      const axisKeyA = axisKeys[0] || null;
      const axisKeyB = axisKeys[1] || null;
      const definitions = variableDefinitions || {};
      const missingSelections = [];

      if (!axisKeyA || !axisKeyB || axisKeyA === axisKeyB) {
        latestResultsMode = mode;
        return {
          pricingData: [],
          bufferPercent,
          revenueNeeded: null,
          mode,
          manualNetSummary: null,
          axisMeta: null,
          axisKeys: null,
          axisInfo: null,
          missingSelections,
          missingAxes: true
        };
      }

      const valueSets = {
        studentsPerClass: Array.isArray(studentsPerClass) ? studentsPerClass : [],
        classesPerWeek: Array.isArray(classesPerWeek) ? classesPerWeek : [],
        activeMonths: Array.isArray(activeMonthsValues) ? activeMonthsValues : [],
        weeksOffPerMonth: Array.isArray(weeksOffPerMonthValues) ? weeksOffPerMonthValues : [],
        daysOffPerWeek: Array.isArray(daysOffPerWeekValues) ? daysOffPerWeekValues : []
      };

      const iterationValues = {};
      let invalidAxis = false;
      VARIABLE_ORDER.forEach(key => {
        const values = Array.isArray(valueSets[key]) ? valueSets[key] : [];
        const normalized = Array.from(new Set(values.map(value => Number(value))))
          .filter(Number.isFinite)
          .sort((a, b) => a - b);
        if (!normalized.length) {
          iterationValues[key] = [];
          if (key === axisKeyA || key === axisKeyB) {
            invalidAxis = true;
          }
          return;
        }
        if (key === axisKeyA || key === axisKeyB) {
          iterationValues[key] = normalized;
          return;
        }
        if (normalized.length === 1) {
          iterationValues[key] = normalized;
          return;
        }
        const selected = Number(selection?.fixedValues?.[key]);
        if (Number.isFinite(selected) && normalized.includes(selected)) {
          iterationValues[key] = [selected];
        } else {
          iterationValues[key] = [];
          missingSelections.push(key);
        }
      });

      if (invalidAxis || missingSelections.length) {
        latestResultsMode = mode;
        return {
          pricingData: [],
          bufferPercent,
          revenueNeeded: null,
          mode,
          manualNetSummary: null,
          axisMeta: null,
          axisKeys: null,
          axisInfo: null,
          missingSelections,
          missingAxes: invalidAxis
        };
      }

      const axisValuesA = iterationValues[axisKeyA] || [];
      const axisValuesB = iterationValues[axisKeyB] || [];
      if (!axisValuesA.length || !axisValuesB.length) {
        latestResultsMode = mode;
        return {
          pricingData: [],
          bufferPercent,
          revenueNeeded: null,
          mode,
          manualNetSummary: null,
          axisMeta: null,
          axisKeys: null,
          axisInfo: null,
          missingSelections: [],
          missingAxes: true
        };
      }

      const orderedKeys = VARIABLE_ORDER.filter(key => (iterationValues[key] || []).length);
      if (!orderedKeys.length) {
        latestResultsMode = mode;
        return {
          pricingData: [],
          bufferPercent,
          revenueNeeded: null,
          mode,
          manualNetSummary: null,
          axisMeta: null,
          axisKeys: null,
          axisInfo: null,
          missingSelections: [],
          missingAxes: true
        };
      }

      const combinations = [];
      (function buildCombination(index, current) {
        if (index >= orderedKeys.length) {
          combinations.push({ ...current });
          return;
        }
        const key = orderedKeys[index];
        const values = iterationValues[key];
        if (!values || !values.length) {
          return;
        }
        values.forEach(value => {
          current[key] = value;
          buildCombination(index + 1, current);
        });
      })(0, {});

      if (!combinations.length) {
        latestResultsMode = mode;
        return {
          pricingData: [],
          bufferPercent,
          revenueNeeded: null,
          mode,
          manualNetSummary: null,
          axisMeta: null,
          axisKeys: null,
          axisInfo: null,
          missingSelections: [],
          missingAxes: true
        };
      }

      let manualNetSummary = null;
      let revenueNeeded = null;
      if (!manualMode) {
        const denominator = Math.max(1 - effectiveTaxRate, 0.0001);
        const profitBeforeTax = targetNet / denominator;
        revenueNeeded = profitBeforeTax + fixedCosts;
        if (!Number.isFinite(revenueNeeded) || revenueNeeded <= 0) {
          revenueNeeded = null;
        }
      }

      const axisMeta = {
        rows: definitions[axisKeyA] || VARIABLE_META[axisKeyA] || { label: axisKeyA, axisLabel: axisKeyA },
        columns: definitions[axisKeyB] || VARIABLE_META[axisKeyB] || { label: axisKeyB, axisLabel: axisKeyB }
      };

      const axisInfo = {
        rows: {
          key: axisKeyA,
          values: axisValuesA.map(value => ({
            value,
            label: formatVariableValue(axisKeyA, value)
          }))
        },
        columns: {
          key: axisKeyB,
          values: axisValuesB.map(value => ({
            value,
            label: formatVariableValue(axisKeyB, value)
          }))
        }
      };

      const combinationResults = combinations
        .map(combination => computeCombinationResult(combination))
        .filter(Boolean);

      if (!combinationResults.length) {
        latestResultsMode = mode;
        return {
          pricingData: [],
          bufferPercent,
          revenueNeeded,
          mode,
          manualNetSummary,
          axisMeta,
          axisKeys: { rows: axisKeyA, columns: axisKeyB },
          axisInfo,
          missingSelections: [],
          missingAxes: false
        };
      }

      const pricingData = axisValuesA.map(rowValue => {
        const rowResults = combinationResults.filter(result =>
          areValuesEqual(result.combination[axisKeyA], rowValue)
        );
        const columns = axisValuesB.map(columnValue => {
          return (
            rowResults.find(result => areValuesEqual(result.combination[axisKeyB], columnValue)) ||
            null
          );
        });
        return {
          axisKey: axisKeyA,
          value: rowValue,
          label: formatVariableValue(axisKeyA, rowValue),
          columns
        };
      });

      latestResultsMode = mode;
      latestResults = combinationResults.flatMap(result => buildLatestResultRows(result, bufferPercent));

      return {
        pricingData,
        bufferPercent,
        revenueNeeded,
        mode,
        manualNetSummary,
        axisMeta,
        axisKeys: { rows: axisKeyA, columns: axisKeyB },
        axisInfo,
        missingSelections: []
      };

      function computeCombinationResult(combination) {
        const students = Number(combination.studentsPerClass);
        const classesPerWeekValue = Number(combination.classesPerWeek);
        if (!Number.isFinite(students) || students <= 0 || !Number.isFinite(classesPerWeekValue) || classesPerWeekValue <= 0) {
          return null;
        }

        const activeMonthsValue = Number(combination.activeMonths);
        const weeksOffValue = Number(combination.weeksOffPerMonth);
        const daysOffValue = Number(combination.daysOffPerWeek);
        const activeMonthShareValue = Math.min(Math.max(activeMonthsValue / 12, 0), 1);
        const weeksShareValue = Math.min(Math.max((4 - weeksOffValue) / 4, 0), 1);
        const workingWeeksValue = WEEKS_PER_YEAR * activeMonthShareValue * weeksShareValue;
        if (!Number.isFinite(workingWeeksValue) || workingWeeksValue <= 0) {
          return null;
        }

        const workingDaysPerWeekValue = Math.max(BASE_WORK_DAYS_PER_WEEK - daysOffValue, 0);
        const workingDaysPerYearValue = workingWeeksValue * workingDaysPerWeekValue;
        const classesPerYearValue = classesPerWeekValue * workingWeeksValue;
        const effectiveClassesPerYear = Math.max(classesPerYearValue, 1);

        const monthlyStudentCost = variableCostPerStudentMonthly * students * activeMonthsValue;
        const annualVariableCosts =
          variableCostPerClass * classesPerYearValue +
          variableCostPerStudent * students * classesPerYearValue +
          monthlyStudentCost;

        if (manualMode) {
          const vatDivisor = Math.max(1 + vatRate, 0.0001);
          const priceInclVatPerStudent = lessonCostInclVat;
          const priceExVatPerStudent = lessonCostInclVat / vatDivisor;
          const attendanceMultiplier = Math.max(1 - buffer, 0);

          const annualRevenue = priceExVatPerStudent * students * classesPerYearValue;
          const bufferedRevenue = annualRevenue * attendanceMultiplier;

          const annualNet = computeNetIncomeFromRevenue(
            annualRevenue,
            fixedCosts,
            effectiveTaxRate,
            annualVariableCosts
          );
          const bufferedAnnualNet = computeNetIncomeFromRevenue(
            bufferedRevenue,
            fixedCosts,
            effectiveTaxRate,
            annualVariableCosts
          );

          const baseBreakdown = buildPriceBreakdown({
            priceExVatValue: priceExVatPerStudent,
            priceInclVatValue: priceInclVatPerStudent,
            studentCount: students,
            classesPerYearValue,
            activeMonthsValue
          });

          const monthlyNet = Number.isFinite(annualNet) && activeMonthsValue > 0 ? annualNet / activeMonthsValue : null;
          const bufferedMonthlyNet =
            Number.isFinite(bufferedAnnualNet) && activeMonthsValue > 0 ? bufferedAnnualNet / activeMonthsValue : null;
          const weeklyNet = Number.isFinite(annualNet) && workingWeeksValue > 0 ? annualNet / workingWeeksValue : null;
          const bufferedWeeklyNet =
            Number.isFinite(bufferedAnnualNet) && workingWeeksValue > 0 ? bufferedAnnualNet / workingWeeksValue : null;
          const averageNetMonthly = Number.isFinite(annualNet) ? annualNet / MONTHS_PER_YEAR : null;
          const averageNetWeekly = Number.isFinite(annualNet) ? annualNet / WEEKS_PER_YEAR : null;
          const averageBufferedNetMonthly = Number.isFinite(bufferedAnnualNet) ? bufferedAnnualNet / MONTHS_PER_YEAR : null;
          const averageBufferedNetWeekly = Number.isFinite(bufferedAnnualNet) ? bufferedAnnualNet / WEEKS_PER_YEAR : null;

          const grossAnnual = convertNetToGross(annualNet, effectiveTaxRate);
          const bufferedGrossAnnual = convertNetToGross(bufferedAnnualNet, effectiveTaxRate);
          const grossMonthly = Number.isFinite(grossAnnual) && activeMonthsValue > 0 ? grossAnnual / activeMonthsValue : null;
          const bufferedGrossMonthly =
            Number.isFinite(bufferedGrossAnnual) && activeMonthsValue > 0 ? bufferedGrossAnnual / activeMonthsValue : null;
          const grossWeekly = Number.isFinite(grossAnnual) && workingWeeksValue > 0 ? grossAnnual / workingWeeksValue : null;
          const bufferedGrossWeekly =
            Number.isFinite(bufferedGrossAnnual) && workingWeeksValue > 0 ? bufferedGrossAnnual / workingWeeksValue : null;
          const grossAverageMonthly = Number.isFinite(grossAnnual) ? grossAnnual / MONTHS_PER_YEAR : null;
          const grossAverageWeekly = Number.isFinite(grossAnnual) ? grossAnnual / WEEKS_PER_YEAR : null;
          const bufferedGrossAverageMonthly = Number.isFinite(bufferedGrossAnnual)
            ? bufferedGrossAnnual / MONTHS_PER_YEAR
            : null;
          const bufferedGrossAverageWeekly = Number.isFinite(bufferedGrossAnnual)
            ? bufferedGrossAnnual / WEEKS_PER_YEAR
            : null;

          if (!manualNetSummary && Number.isFinite(annualNet)) {
            manualNetSummary = {
              annual: annualNet,
              monthly: monthlyNet,
              weekly: weeklyNet,
              averageWeekly: averageNetWeekly,
              averageMonthly: averageNetMonthly
            };
          }

          return {
            combination,
            students,
            classesPerWeek: classesPerWeekValue,
            classesPerYear: classesPerYearValue,
            workingWeeks: workingWeeksValue,
            workingDaysPerWeek: workingDaysPerWeekValue,
            workingDaysPerYear: workingDaysPerYearValue,
            activeMonths: activeMonthsValue,
            base: {
              net: {
                annual: annualNet,
                monthly: monthlyNet,
                weekly: weeklyNet,
                averageMonthly: averageNetMonthly,
                averageWeekly: averageNetWeekly
              },
              gross: {
                annual: grossAnnual,
                monthly: grossMonthly,
                weekly: grossWeekly,
                averageMonthly: grossAverageMonthly,
                averageWeekly: grossAverageWeekly
              },
              price: {
                inclVat: lessonCostInclVat,
                exVat: priceExVatPerStudent
              },
              breakdown: baseBreakdown
            },
            buffered: {
              net: {
                annual: bufferedAnnualNet,
                monthly: bufferedMonthlyNet,
                weekly: bufferedWeeklyNet,
                averageMonthly: averageBufferedNetMonthly,
                averageWeekly: averageBufferedNetWeekly
              },
              gross: {
                annual: bufferedGrossAnnual,
                monthly: bufferedGrossMonthly,
                weekly: bufferedGrossWeekly,
                averageMonthly: bufferedGrossAverageMonthly,
                averageWeekly: bufferedGrossAverageWeekly
              },
              price: {
                inclVat: lessonCostInclVat,
                exVat: priceExVatPerStudent
              },
              breakdown: baseBreakdown
            }
          };
        }

        if (!Number.isFinite(revenueNeeded) || revenueNeeded === null) {
          return null;
        }

        const revenueNeededForCombo = revenueNeeded + annualVariableCosts;
        const revenuePerClass = revenueNeededForCombo / Math.max(effectiveClassesPerYear, 1);
        const priceExVat = revenuePerClass / Math.max(students, 1);
        const bufferedExVat = priceExVat * (1 + buffer);
        const priceInclVat = priceExVat * (1 + vatRate);
        const bufferedInclVat = bufferedExVat * (1 + vatRate);

        const baseBreakdown = buildPriceBreakdown({
          priceExVatValue: priceExVat,
          priceInclVatValue: priceInclVat,
          studentCount: students,
          classesPerYearValue,
          activeMonthsValue
        });
        const bufferedBreakdown = buildPriceBreakdown({
          priceExVatValue: bufferedExVat,
          priceInclVatValue: bufferedInclVat,
          studentCount: students,
          classesPerYearValue,
          activeMonthsValue
        });

        const baseAnnualNet = Number.isFinite(baseBreakdown?.perLesson?.netIncome)
          ? baseBreakdown.perLesson.netIncome * classesPerYearValue
          : null;
        const bufferedAnnualNet = Number.isFinite(bufferedBreakdown?.perLesson?.netIncome)
          ? bufferedBreakdown.perLesson.netIncome * classesPerYearValue
          : null;

        const baseMonthlyNet = Number.isFinite(baseAnnualNet) && activeMonthsValue > 0 ? baseAnnualNet / activeMonthsValue : null;
        const bufferedMonthlyNet =
          Number.isFinite(bufferedAnnualNet) && activeMonthsValue > 0 ? bufferedAnnualNet / activeMonthsValue : null;
        const baseWeeklyNet = Number.isFinite(baseAnnualNet) && workingWeeksValue > 0 ? baseAnnualNet / workingWeeksValue : null;
        const bufferedWeeklyNet =
          Number.isFinite(bufferedAnnualNet) && workingWeeksValue > 0 ? bufferedAnnualNet / workingWeeksValue : null;

        const baseAverageNetMonthly = Number.isFinite(baseAnnualNet) ? baseAnnualNet / MONTHS_PER_YEAR : null;
        const baseAverageNetWeekly = Number.isFinite(baseAnnualNet) ? baseAnnualNet / WEEKS_PER_YEAR : null;
        const bufferedAverageNetMonthly = Number.isFinite(bufferedAnnualNet) ? bufferedAnnualNet / MONTHS_PER_YEAR : null;
        const bufferedAverageNetWeekly = Number.isFinite(bufferedAnnualNet) ? bufferedAnnualNet / WEEKS_PER_YEAR : null;

        const baseGrossAnnual = convertNetToGross(baseAnnualNet, effectiveTaxRate);
        const bufferedGrossAnnual = convertNetToGross(bufferedAnnualNet, effectiveTaxRate);
        const baseGrossMonthly = Number.isFinite(baseGrossAnnual) && activeMonthsValue > 0 ? baseGrossAnnual / activeMonthsValue : null;
        const bufferedGrossMonthly =
          Number.isFinite(bufferedGrossAnnual) && activeMonthsValue > 0 ? bufferedGrossAnnual / activeMonthsValue : null;
        const baseGrossWeekly = Number.isFinite(baseGrossAnnual) && workingWeeksValue > 0 ? baseGrossAnnual / workingWeeksValue : null;
        const bufferedGrossWeekly =
          Number.isFinite(bufferedGrossAnnual) && workingWeeksValue > 0 ? bufferedGrossAnnual / workingWeeksValue : null;
        const baseGrossAverageMonthly = Number.isFinite(baseGrossAnnual) ? baseGrossAnnual / MONTHS_PER_YEAR : null;
        const baseGrossAverageWeekly = Number.isFinite(baseGrossAnnual) ? baseGrossAnnual / WEEKS_PER_YEAR : null;
        const bufferedGrossAverageMonthly = Number.isFinite(bufferedGrossAnnual)
          ? bufferedGrossAnnual / MONTHS_PER_YEAR
          : null;
        const bufferedGrossAverageWeekly = Number.isFinite(bufferedGrossAnnual)
          ? bufferedGrossAnnual / WEEKS_PER_YEAR
          : null;

        return {
          combination,
          students,
          classesPerWeek: classesPerWeekValue,
          classesPerYear: classesPerYearValue,
          workingWeeks: workingWeeksValue,
          workingDaysPerWeek: workingDaysPerWeekValue,
          workingDaysPerYear: workingDaysPerYearValue,
          activeMonths: activeMonthsValue,
          base: {
            net: {
              annual: baseAnnualNet,
              monthly: baseMonthlyNet,
              weekly: baseWeeklyNet,
              averageMonthly: baseAverageNetMonthly,
              averageWeekly: baseAverageNetWeekly
            },
            gross: {
              annual: baseGrossAnnual,
              monthly: baseGrossMonthly,
              weekly: baseGrossWeekly,
              averageMonthly: baseGrossAverageMonthly,
              averageWeekly: baseGrossAverageWeekly
            },
            price: {
              inclVat: priceInclVat,
              exVat: priceExVat
            },
            breakdown: baseBreakdown
          },
          buffered: {
            net: {
              annual: bufferedAnnualNet,
              monthly: bufferedMonthlyNet,
              weekly: bufferedWeeklyNet,
              averageMonthly: bufferedAverageNetMonthly,
              averageWeekly: bufferedAverageNetWeekly
            },
            gross: {
              annual: bufferedGrossAnnual,
              monthly: bufferedGrossMonthly,
              weekly: bufferedGrossWeekly,
              averageMonthly: bufferedGrossAverageMonthly,
              averageWeekly: bufferedGrossAverageWeekly
            },
            price: {
              inclVat: bufferedInclVat,
              exVat: bufferedExVat
            },
            breakdown: bufferedBreakdown
          }
        };
      }

      function buildPriceBreakdown({
        priceExVatValue,
        priceInclVatValue,
        studentCount,
        classesPerYearValue,
        activeMonthsValue
      }) {
        const normalizedPriceExVat = Number.isFinite(priceExVatValue) ? priceExVatValue : 0;
        const normalizedPriceInclVat = Number.isFinite(priceInclVatValue) ? priceInclVatValue : 0;
        const actualStudents = Number.isFinite(studentCount) ? studentCount : 0;
        const actualClassesPerYear = Number.isFinite(classesPerYearValue) ? classesPerYearValue : 0;
        const safeStudents = actualStudents > 0 ? actualStudents : 1;
        const fixedAllocationPerLesson = actualClassesPerYear > 0 ? fixedCosts / actualClassesPerYear : 0;
        const vatPerStudent = normalizedPriceInclVat - normalizedPriceExVat;
        const vatPerLesson = vatPerStudent * actualStudents;
        const monthlyCostTotal = variableCostPerStudentMonthly * actualStudents * Math.max(activeMonthsValue, 0);
        const monthlyCostPerLesson = actualClassesPerYear > 0 ? monthlyCostTotal / actualClassesPerYear : 0;
        const variableCostsPerLesson =
          variableCostPerClass + variableCostPerStudent * actualStudents + monthlyCostPerLesson;
        const revenueExVatPerLesson = normalizedPriceExVat * actualStudents;
        const profitBeforeTaxPerLesson = revenueExVatPerLesson - variableCostsPerLesson - fixedAllocationPerLesson;
        const incomeTaxPerLesson = profitBeforeTaxPerLesson > 0 ? profitBeforeTaxPerLesson * effectiveTaxRate : 0;
        const netIncomePerLesson = profitBeforeTaxPerLesson - incomeTaxPerLesson;

        return {
          perLesson: {
            vat: vatPerLesson,
            variableCosts: variableCostsPerLesson,
            fixedCostAllocation: fixedAllocationPerLesson,
            incomeTax: incomeTaxPerLesson,
            netIncome: netIncomePerLesson
          },
          perStudent: {
            vat: vatPerStudent,
            variableCosts: variableCostsPerLesson / safeStudents,
            fixedCostAllocation: fixedAllocationPerLesson / safeStudents,
            incomeTax: incomeTaxPerLesson / safeStudents,
            netIncome: netIncomePerLesson / safeStudents
          },
          totals: {
            priceInclVatPerStudent: normalizedPriceInclVat,
            priceExVatPerStudent: normalizedPriceExVat,
            priceInclVatPerLesson: normalizedPriceInclVat * actualStudents,
            priceExVatPerLesson: revenueExVatPerLesson,
            students: actualStudents,
            classesPerYear: actualClassesPerYear
          }
        };
      }

      function buildLatestResultRows(result, bufferPercentValue) {
        const axisValues = {
          [axisKeyA]: result.combination[axisKeyA],
          [axisKeyB]: result.combination[axisKeyB]
        };
        const baseRow = {
          variant: 'Base (no buffer)',
          axis: axisValues,
          students: result.students,
          classesPerWeek: result.classesPerWeek,
          netAnnual: result.base.net.annual,
          grossAnnual: result.base.gross.annual,
          netMonthly: result.base.net.monthly,
          grossMonthly: result.base.gross.monthly,
          priceInclVat: result.base.price?.inclVat ?? null,
          priceExVat: result.base.price?.exVat ?? null
        };
        const bufferedRow = {
          variant: `Buffered +${formatFixed(bufferPercentValue, 1)}%`,
          axis: axisValues,
          students: result.students,
          classesPerWeek: result.classesPerWeek,
          netAnnual: result.buffered.net.annual,
          grossAnnual: result.buffered.gross.annual,
          netMonthly: result.buffered.net.monthly,
          grossMonthly: result.buffered.gross.monthly,
          priceInclVat: result.buffered.price?.inclVat ?? null,
          priceExVat: result.buffered.price?.exVat ?? null
        };
        return [baseRow, bufferedRow];
      }
    }

    function render() {
      const inputs = getInputs();
      latestInputsSnapshot = cloneInputs(inputs);
      const variableDefinitions = buildVariableDefinitions(inputs);
      updateVariableSelectionState(variableDefinitions);
      renderVariableControls(variableDefinitions);

      const {
        pricingData,
        bufferPercent,
        revenueNeeded,
        mode,
        manualNetSummary,
        axisMeta,
        axisKeys,
        axisInfo,
        missingSelections = [],
        missingAxes = false
      } = computeTables(inputs, variableSelection, variableDefinitions);

      if (mode === PRICING_MODE_LESSON && manualNetSummary) {
        if (Number.isFinite(manualNetSummary.annual)) {
          writeDesiredIncomeNet('year', Math.max(manualNetSummary.annual, 0));
          inputs.targetNet = manualNetSummary.annual;
        }

        if (Number.isFinite(manualNetSummary.weekly)) {
          writeDesiredIncomeNet('week', Math.max(manualNetSummary.weekly, 0));
          inputs.targetNetPerWeek = manualNetSummary.weekly;
        } else {
          writeDesiredIncomeNet('week', null);
          inputs.targetNetPerWeek = null;
        }

        if (Number.isFinite(manualNetSummary.monthly)) {
          writeDesiredIncomeNet('month', Math.max(manualNetSummary.monthly, 0));
          inputs.targetNetPerMonth = manualNetSummary.monthly;
        } else {
          writeDesiredIncomeNet('month', null);
          inputs.targetNetPerMonth = null;
        }

        if (Number.isFinite(manualNetSummary.averageWeekly)) {
          writeDesiredIncomeNet('avgWeek', Math.max(manualNetSummary.averageWeekly, 0));
          inputs.targetNetAveragePerWeek = manualNetSummary.averageWeekly;
        } else {
          writeDesiredIncomeNet('avgWeek', null);
          inputs.targetNetAveragePerWeek = null;
        }

        if (Number.isFinite(manualNetSummary.averageMonthly)) {
          writeDesiredIncomeNet('avgMonth', Math.max(manualNetSummary.averageMonthly, 0));
          inputs.targetNetAveragePerMonth = manualNetSummary.averageMonthly;
        } else {
          writeDesiredIncomeNet('avgMonth', null);
          inputs.targetNetAveragePerMonth = null;
        }

        refreshDesiredIncomeDisplay(
          {
            year: manualNetSummary.annual,
            week: manualNetSummary.weekly,
            month: manualNetSummary.monthly,
            avgWeek: manualNetSummary.averageWeekly,
            avgMonth: manualNetSummary.averageMonthly
          },
          inputs.taxRate
        );
        refreshAcceptableIncomeDisplay(inputs.taxRate, { force: true });
      }

      latestCurrencySymbol = inputs.currencySymbol;
      latestPricingMode = mode;
      latestBufferPercent = bufferPercent;
      latestPricingData = pricingData.length ? pricingData : null;

      closeActiveInfoIcon();

      if (!pricingData.length) {
        let emptyMessage;
        if (missingAxes) {
          emptyMessage = 'Choose two table variables above to generate results.';
        } else if (Array.isArray(missingSelections) && missingSelections.length) {
          const labels = missingSelections
            .map(key => variableDefinitions[key]?.label || VARIABLE_META[key]?.label || key);
          if (labels.length === 1) {
            emptyMessage = `Select a value for ${labels[0]} to generate the table.`;
          } else {
            const lastLabel = labels.pop();
            emptyMessage = `Select values for ${labels.join(', ')} and ${lastLabel} to generate the table.`;
          }
        } else {
          emptyMessage = 'No valid combinations available for the current inputs.';
        }

        tablesContainer.innerHTML = `
          <div class="card">
            <p class="status-message">${escapeHtml(emptyMessage)}</p>
          </div>
        `;
        latestPricingData = null;
        scheduleTablesLayoutUpdate();
      } else {
        const pricingTable = buildPricingTable(pricingData, inputs.currencySymbol, bufferPercent, {
          mode,
          showBasePrices,
          minLessonPrice: inputs.lessonPriceMin,
          maxLessonPrice: inputs.lessonPriceMax,
          acceptableIncome: {
            basis: acceptableIncomeBasis,
            minAnnualNet: acceptableIncomeMinAnnualNet,
            maxAnnualNet: acceptableIncomeMaxAnnualNet
          },
          desiredIncomeDisplayMode,
          taxRate: inputs.taxRate,
          activeMonths: inputs.activeMonths,
          hoursPerLesson: inputs.hoursPerLesson,
          axisMeta,
          axisInfo,
          axisKeys
        });
        const targetsTable = mode === PRICING_MODE_LESSON
          ? ''
          : buildActiveTargetsTable({
              currencySymbol: inputs.currencySymbol,
              revenueNeeded,
              workingDaysPerYear: inputs.workingDaysPerYear,
              workingWeeks: inputs.workingWeeks,
              activeMonths: inputs.activeMonths
            });

        tablesContainer.innerHTML = pricingTable + targetsTable;
        scheduleTablesLayoutUpdate();
      }

      if (breakdownDialog && !breakdownDialog.hidden) {
        if (!latestPricingData || !refreshBreakdownDialog()) {
          closeBreakdownDialog();
        }
      } else if (!latestPricingData) {
        activeBreakdownContext = null;
        breakdownTriggerElement = null;
      }

      enhanceAllInfoIcons();
      renderAssumptions(inputs, { mode });
    }

    function renderAssumptions(inputs, { mode } = {}) {
      const {
        targetNet,
        targetNetPerWeek,
        targetNetPerMonth,
        targetNetAveragePerWeek,
        targetNetAveragePerMonth,
        taxRate,
        fixedCosts,
        variableCostPerClass,
        variableCostPerStudent,
        variableCostPerStudentMonthly,
        vatRate,
        classesPerWeek,
        studentsPerClass,
        hoursPerLesson,
        workingWeeks,
        bufferPercent,
        currencySymbol,
        daysOffPerWeek,
        workingDaysPerWeek,
        workingDaysPerYear,
        activeMonths,
        activeMonthsValues,
        weeksOffPerMonth,
        weeksOffPerMonthValues,
        daysOffPerWeekValues,
        activeMonthShare,
        weeksShare,
        lessonCostInclVat,
        lessonPriceMin,
        lessonPriceMax
      } = inputs;

      const activeMonthPercentage = activeMonthShare * 100;
      const activeWeeksPercentage = weeksShare * 100;
      const monthsOff = MONTHS_PER_YEAR - activeMonths;

      const defaultActiveMonthsValue = Array.isArray(activeMonthsValues) && activeMonthsValues.length
        ? activeMonthsValues[0]
        : activeMonths;
      const defaultWeeksOffPerMonthValue = Array.isArray(weeksOffPerMonthValues) && weeksOffPerMonthValues.length
        ? weeksOffPerMonthValues[0]
        : weeksOffPerMonth;
      const defaultDaysOffPerWeekValue = Array.isArray(daysOffPerWeekValues) && daysOffPerWeekValues.length
        ? daysOffPerWeekValues[0]
        : daysOffPerWeek;

      const activeMonthsSummaryRaw = summarizeVariableValues('activeMonths', activeMonthsValues);
      const weeksOffSummaryRaw = summarizeVariableValues('weeksOffPerMonth', weeksOffPerMonthValues);
      const daysOffSummaryRaw = summarizeVariableValues('daysOffPerWeek', daysOffPerWeekValues);

      const activeMonthsSummary = activeMonthsSummaryRaw === 'n/a'
        ? formatFixed(activeMonths, 0)
        : activeMonthsSummaryRaw;
      const weeksOffSummary = weeksOffSummaryRaw === 'n/a'
        ? formatFixed(weeksOffPerMonth, 0)
        : weeksOffSummaryRaw;
      const daysOffSummary = daysOffSummaryRaw === 'n/a'
        ? formatFixed(daysOffPerWeek, 0)
        : daysOffSummaryRaw;

      const targetPerWeekDisplay = Number.isFinite(targetNetPerWeek)
        ? formatCurrency(currencySymbol, targetNetPerWeek)
        : '–';
      const targetPerMonthDisplay = Number.isFinite(targetNetPerMonth)
        ? formatCurrency(currencySymbol, targetNetPerMonth)
        : '–';
      const targetAveragePerWeekDisplay = Number.isFinite(targetNetAveragePerWeek)
        ? formatCurrency(currencySymbol, targetNetAveragePerWeek)
        : '–';
      const targetAveragePerMonthDisplay = Number.isFinite(targetNetAveragePerMonth)
        ? formatCurrency(currencySymbol, targetNetAveragePerMonth)
        : '–';

      const manualLessonLine = Number.isFinite(lessonCostInclVat)
        ? `Preferred lesson price (incl. VAT): ${currencySymbol}${formatFixed(lessonCostInclVat, 2)}`
        : 'Preferred lesson price (incl. VAT): not set';
      const lessonMinLine = Number.isFinite(lessonPriceMin)
        ? `Minimum preferred lesson price (incl. VAT): ${currencySymbol}${formatFixed(lessonPriceMin, 2)}`
        : 'Minimum preferred lesson price (incl. VAT): not set';
      const lessonMaxLine = Number.isFinite(lessonPriceMax)
        ? `Maximum preferred lesson price (incl. VAT): ${currencySymbol}${formatFixed(lessonPriceMax, 2)}`
        : 'Maximum preferred lesson price (incl. VAT): not set';

      const listItems = [
        `Net income per year: ${formatCurrency(currencySymbol, targetNet)}`,
        `Net income per active week: ${targetPerWeekDisplay}`,
        `Net income per active month: ${targetPerMonthDisplay}`,
        `Average weekly net income: ${targetAveragePerWeekDisplay}`,
        `Average monthly net income: ${targetAveragePerMonthDisplay}`,
        manualLessonLine,
        lessonMinLine,
        lessonMaxLine,
        `Effective income tax rate: ${formatFixed(taxRate * 100, 1)}%`,
        `Fixed annual costs: ${formatCurrency(currencySymbol, fixedCosts)}`,
        `Variable cost per class: ${formatCurrency(currencySymbol, variableCostPerClass)} (per scheduled class)`,
        `Variable cost per student: ${formatCurrency(currencySymbol, variableCostPerStudent)} (per student per class)`,
        `Variable monthly cost per student: ${formatCurrency(currencySymbol, variableCostPerStudentMonthly)} (multiplied by class size each active month)`,
        `Active months per year considered: ${activeMonthsSummary} (default ${formatFixed(defaultActiveMonthsValue, 0)}; ${formatFixed(activeMonthPercentage, 1)}% of the year active)`,
        `Weeks off per active month considered: ${weeksOffSummary} (default ${formatFixed(defaultWeeksOffPerMonthValue, 0)}; ${formatFixed(activeWeeksPercentage, 1)}% active weeks)`,
        `Days off per 7-day week considered: ${daysOffSummary} (default ${formatFixed(defaultDaysOffPerWeekValue, 0)}; ≈ ${formatFixed(workingDaysPerWeek, 2)} working days when active)`,
        `Months off per year (based on defaults): ${formatFixed(monthsOff, 2)}`,
        `Estimated working weeks per year: ${formatFixed(workingWeeks, 2)}`,
        `Estimated working days per year: ${formatFixed(workingDaysPerYear, 2)}`,
        `Classes per week considered: ${classesPerWeek.length ? classesPerWeek.join(', ') : 'none'}`,
        `Students per class considered: ${studentsPerClass.length ? studentsPerClass.join(', ') : 'none'}`,
        `Hours per lesson: ${formatFixed(hoursPerLesson, 2)}`,
        `Extra safety margin (% on top of desired income): ${formatFixed(bufferPercent, 1)}%`,
        `VAT/BTW rate: ${formatFixed(vatRate * 100, 1)}%`,
        `Currency symbol: ${currencySymbol}`,
        `Prices are rounded to whole currency units for display and CSV export.`
      ];

      assumptionsList.innerHTML = listItems.map(item => `<li>${item}</li>`).join('');
    }

    function downloadCsv() {
      if (!latestResults.length) {
        controls.statusMessage.textContent = 'Add at least one class and student value before exporting CSV.';
        setTimeout(() => {
          controls.statusMessage.textContent = '';
        }, 2500);
        return;
      }

      let header;
      let rows;

      const formatCsvNumber = value => (Number.isFinite(value) ? Math.round(value) : '');

      if (latestResultsMode === PRICING_MODE_LESSON) {
        header = [
          'Variant',
          'Students',
          'Classes per week',
          'Classes per year',
          'Monthly net income',
          'Monthly gross income',
          'Annual net income',
          'Annual gross income'
        ].join(',');
        rows = latestResults.map(entry => [
          entry.variant,
          entry.students,
          entry.classesPerWeek,
          entry.classesPerYear,
          formatCsvNumber(entry.netMonthly),
          formatCsvNumber(entry.grossMonthly),
          formatCsvNumber(entry.netAnnual),
          formatCsvNumber(entry.grossAnnual)
        ].join(','));
      } else {
        header = [
          'Variant',
          'Students',
          'Classes per week',
          'Classes per year',
          'Monthly net income',
          'Monthly gross income',
          'Annual net income',
          'Annual gross income',
          'Lesson price incl VAT',
          'Lesson price ex VAT'
        ].join(',');
        rows = latestResults.map(entry => [
          entry.variant,
          entry.students,
          entry.classesPerWeek,
          entry.classesPerYear,
          formatCsvNumber(entry.netMonthly),
          formatCsvNumber(entry.grossMonthly),
          formatCsvNumber(entry.netAnnual),
          formatCsvNumber(entry.grossAnnual),
          Number.isFinite(entry.priceInclVat) ? formatFixed(entry.priceInclVat, 2) : '',
          Number.isFinite(entry.priceExVat) ? formatFixed(entry.priceExVat, 2) : ''
        ].join(','));
      }

      const csvContent = [header, ...rows].join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      const timestamp = new Date().toISOString().slice(0, 10);
      link.download = `income-calculator-${timestamp}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      controls.statusMessage.textContent = latestResultsMode === PRICING_MODE_LESSON
        ? 'CSV download started. File lists monthly and annual net and gross income for each combination.'
        : 'CSV download started. File lists net and gross incomes plus lesson prices for each combination.';
      setTimeout(() => {
        controls.statusMessage.textContent = '';
      }, 2500);
    }

    [
      { control: controls.targetNet, basis: 'year' },
      { control: controls.targetNetWeek, basis: 'week' },
      { control: controls.targetNetMonth, basis: 'month' },
      { control: controls.targetNetAverageWeek, basis: 'avgWeek' },
      { control: controls.targetNetAverageMonth, basis: 'avgMonth' }
    ].forEach(({ control, basis }) => {
      if (!(control instanceof HTMLInputElement)) return;
      const handleInput = () => {
        targetNetBasis = basis;
        updateDesiredIncomeFromField(basis);
        desiredIncomePreviousNetValues = null;
      };
      control.addEventListener('focus', () => {
        control.dataset.editing = 'true';
      });
      control.addEventListener('blur', () => {
        delete control.dataset.editing;
      });
      control.addEventListener('input', handleInput);
      control.addEventListener('change', () => {
        handleInput();
        const netValue = readDesiredIncomeNet(basis, null);
        if (Number.isFinite(netValue)) {
          const displayValue = desiredIncomeDisplayMode === 'gross'
            ? convertNetToGross(netValue, getCurrentTaxRate())
            : netValue;
          control.value = formatFixed(displayValue, 2);
        }
      });
    });

    if (controls.acceptableIncomeMin instanceof HTMLInputElement) {
      const updateMin = () => {
        updateAcceptableIncomeFromInput('min');
      };
      controls.acceptableIncomeMin.addEventListener('focus', () => {
        controls.acceptableIncomeMin.dataset.editing = 'true';
      });
      controls.acceptableIncomeMin.addEventListener('blur', () => {
        delete controls.acceptableIncomeMin.dataset.editing;
      });
      controls.acceptableIncomeMin.addEventListener('input', updateMin);
      controls.acceptableIncomeMin.addEventListener('change', () => {
        updateMin();
        refreshAcceptableIncomeDisplay(getCurrentTaxRate(), { force: true });
      });
    }

    if (controls.acceptableIncomeMax instanceof HTMLInputElement) {
      const updateMax = () => {
        updateAcceptableIncomeFromInput('max');
      };
      controls.acceptableIncomeMax.addEventListener('focus', () => {
        controls.acceptableIncomeMax.dataset.editing = 'true';
      });
      controls.acceptableIncomeMax.addEventListener('blur', () => {
        delete controls.acceptableIncomeMax.dataset.editing;
      });
      controls.acceptableIncomeMax.addEventListener('input', updateMax);
      controls.acceptableIncomeMax.addEventListener('change', () => {
        updateMax();
        refreshAcceptableIncomeDisplay(getCurrentTaxRate(), { force: true });
      });
    }

    const acceptableBasisControls = [
      { control: controls.acceptableIncomeBasisMonthly, value: 'monthly' },
      { control: controls.acceptableIncomeBasisAnnual, value: 'annual' }
    ];

    acceptableBasisControls.forEach(({ control, value }) => {
      if (!(control instanceof HTMLInputElement)) {
        return;
      }
      control.addEventListener('change', () => {
        if (!control.checked) {
          return;
        }
        acceptableIncomeBasis = value;
        clearAcceptableIncomeEditingState();
        refreshAcceptableIncomeDisplay(getCurrentTaxRate(), { force: true });
      });
    });

    if (controls.desiredIncomeToggleDisplay instanceof HTMLButtonElement) {
      controls.desiredIncomeToggleDisplay.addEventListener('click', () => {
        desiredIncomeDisplayMode = desiredIncomeDisplayMode === 'gross' ? 'net' : 'gross';
        if (!desiredIncomeLockedAsGross) {
          desiredIncomePreviousNetValues = null;
        }
        clearDesiredIncomeEditingState();
        clearAcceptableIncomeEditingState();
        updateDesiredIncomeTitle();
        updateDesiredIncomeLabels();
        updateAcceptableIncomeBasisLabel();
        updateDesiredIncomeTooltips();
        render();
      });
    }

    if (controls.desiredIncomeToggleInterpretation instanceof HTMLButtonElement) {
      controls.desiredIncomeToggleInterpretation.addEventListener('click', () => {
        const taxRate = getCurrentTaxRate();
        if (!desiredIncomeLockedAsGross) {
          desiredIncomePreviousNetValues = captureDesiredIncomeNetValues();
          previousAcceptableIncome = {
            min: acceptableIncomeMinAnnualNet,
            max: acceptableIncomeMaxAnnualNet
          };
          desiredIncomeDisplayMode = 'gross';
          clearDesiredIncomeLockedGrossStore();
          clearLockedAcceptableIncomeGross();
          desiredIncomeLockedAsGross = true;
          Object.keys(desiredIncomeFieldMap).forEach(key => {
            updateDesiredIncomeFromField(key);
          });
          updateAcceptableIncomeFromInput('min');
          updateAcceptableIncomeFromInput('max');
          clearDesiredIncomeEditingState();
          clearAcceptableIncomeEditingState();
          updateDesiredIncomeTitle();
          updateDesiredIncomeLabels();
          updateAcceptableIncomeBasisLabel();
          updateDesiredIncomeTooltips();
          refreshAcceptableIncomeDisplay(taxRate, { force: true });
          render();
        } else {
          desiredIncomeLockedAsGross = false;
          clearDesiredIncomeLockedGrossStore();
          clearLockedAcceptableIncomeGross();
          desiredIncomeDisplayMode = 'net';
          if (desiredIncomePreviousNetValues) {
            restoreDesiredIncomeNetValues(desiredIncomePreviousNetValues);
          }
          if (previousAcceptableIncome) {
            acceptableIncomeMinAnnualNet = Number.isFinite(previousAcceptableIncome.min)
              ? previousAcceptableIncome.min
              : null;
            acceptableIncomeMaxAnnualNet = Number.isFinite(previousAcceptableIncome.max)
              ? previousAcceptableIncome.max
              : null;
          }
          desiredIncomePreviousNetValues = null;
          previousAcceptableIncome = null;
          clearDesiredIncomeEditingState();
          clearAcceptableIncomeEditingState();
          updateDesiredIncomeTitle();
          updateDesiredIncomeLabels();
          updateAcceptableIncomeBasisLabel();
          updateDesiredIncomeTooltips();
          refreshAcceptableIncomeDisplay(taxRate, { force: true });
          render();
        }
      });
    }

    Object.values(controls).forEach(control => {
      if (!(control instanceof HTMLInputElement)) return;
      if (control === controls.lessonCost) return;
      control.addEventListener('change', render);
      control.addEventListener('input', event => {
        if (event.target.type === 'text') return;
        render();
      });
    });

    if (controls.lessonCost instanceof HTMLInputElement) {
      const handleLessonCostInput = () => {
        render();
      };

      controls.lessonCost.addEventListener('input', handleLessonCostInput);
      controls.lessonCost.addEventListener('change', handleLessonCostInput);
    }

    window.addEventListener('resize', scheduleTablesLayoutUpdate);

    tablesContainer.addEventListener('click', event => {
      const priceButton = event.target instanceof HTMLElement
        ? event.target.closest('button.price-line[data-row][data-column][data-variant]')
        : null;

      if (priceButton) {
        const context = {
          rowIndex: Number(priceButton.dataset.row),
          columnIndex: Number(priceButton.dataset.column),
          variant: priceButton.dataset.variant === 'base' ? 'base' : 'buffered'
        };
        openBreakdownDialog(context, priceButton);
        return;
      }

      const toggleButton = event.target instanceof HTMLElement ? event.target.closest('.price-reveal-toggle') : null;
      if (!toggleButton) {
        return;
      }
      event.preventDefault();
      showBasePrices = !showBasePrices;
      render();
      const refreshedToggle = tablesContainer.querySelector('.price-reveal-toggle');
      if (refreshedToggle instanceof HTMLButtonElement) {
        refreshedToggle.focus();
      }
    });

    controls.recalcButton.addEventListener('click', render);
    controls.downloadCsv.addEventListener('click', downloadCsv);

    initializePersistence();
    render();
  </script>
</body>
</html>
